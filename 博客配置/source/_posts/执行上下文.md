---
layout: post
title: 过去杂写整理:执行上下文理解
date: 2017-10-1 00.00
tags: js context 原理
comments: true
---
## 今天拜读了一篇博文 , 感觉又突破了 , 对堆栈和上下文又有了一个新的认识

## 堆和栈的梳理

以前只知道堆和栈是 js 处理内存的方法 . 栈是先进后出 frist in last out , 后进先出
last in frist out!

**堆就感觉是把书放在一个书架上面 , 你只需要知道它名字 , 就可以找到他 .**

**栈就感觉把书放一个大小刚好的箱子里 , 你想要下面的就必须要把上面的拿出来 ;**

<!--more-->

基础数据类型都是按值访问 ; 比如 a=1,b=a, 这都是在堆里面进行操作 , 重新复制了一个
值 , 所以这时当你更改 b 的值 b=2, 而 a 依然是 1, 因为他们其实是**不一样的个体**;

引用数据类型则不一样 , 引用类型访问都是访问的它的指针 , 指向的是他在堆内存的地址
,**复制他的值 , 其实只是复制了他的指针 , 它仍然是指向内存中的那个值**; 比如

```javascript
var m = { a: 10, b: 20 };
var n = m;
n.a = 15;
```

将 m 赋给 n, 其实 n 只是复制的 m 的指针 , 都是指向堆中 { a: 10, b: 20 } 的位置 ;

## 执行上下文

**JavaScript 被称为 " 单线程 " 语言 , 是因为同一时间点 , 只能有一个执行上下文运
行 !**

JavaScript 在处理上下文时会使用栈的方式处理 . 所以是栈是**先进后出 , 后进先出**,
越先进的越在下面 , 越后释放反之亦然 !

* 浏览器一进入 , 会生成全局上下文 , 里面会保存一系列的变量 , 并将全局上下文压入
  栈 , 当 js 代码一句句执行的时候 , 执行到一个函数 , 就创建一个函数及执行上下文
  (js 是函数及作用域 !);
* 创建函数级作用于后 , 也会首先申明一系列变量 , 然后就将这个函数及上下文压入栈 ,
  放在全局上下文上面 , 如果再次遇到执行函数 , 就又会创建一个执行上下文 , 又压入
  栈 ;
* 直到函数运行完没有在建立执行上下文 ( 没有执行函数 ), 这个上下文就会消失 , 然后
  弹出栈 , 然后继续运行 ;

写到这里突然想到了一个情况 :

```javascript
function a() {
  c++;
}

function b() {
  var c = 1;
  a();
  console.log(c);
}

b();
```

在 b 的上下文内 , 执行全局上下文的 a 函数 ; 这种写法会报错 , 因为 a 里面保存的依
然是全局作用域 ( **函数的作用域是在它声明的上下文** )!

全局作用域无法读取下层作用域的值如果在 a 的函数声明前加一个 var c = 2; 这段代码
则也会打印 b 作用域理声明的 c 所以为 1;

这只是突然的想法 ; 继续来说执行上下文 ;

引用一下大神的总结 :

1. 单线程
1. 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待
1. 全局上下文只有唯一的一个，它在浏览器关闭时出栈
1. 函数的执行上下文的个数没有限制
1. 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也
   是如此。

注意的是 return 的时候上下文立即结束 , 上下文立即弹出栈 !

总结 : 上下文很多概念都是以前清楚了的 , 很基础的东西 , 但是这次拉上堆栈 , 感觉对
堆栈有了更深的了解 . [](http://www.jianshu.com/p/a6d37c77e8db)
