<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GoogWin的博客</title>
  <icon>https://www.gravatar.com/avatar/8d23354234732cf351e9e7d52336cb20</icon>
  <subtitle>前端小白练级路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.gmkgmk.com/"/>
  <updated>2018-05-14T02:29:03.731Z</updated>
  <id>http://www.gmkgmk.com/</id>
  
  <author>
    <name>GoogWin</name>
    <email>18408271384@sina.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>koa-compose学习</title>
    <link href="http://www.gmkgmk.com/2018/05/13/%E5%AD%A6%E4%B9%A0%E5%A5%BD%E6%8F%92%E4%BB%B6%E4%B9%8Bkoa-compose/"/>
    <id>http://www.gmkgmk.com/2018/05/13/学习好插件之koa-compose/</id>
    <published>2018-05-13T09:00:00.000Z</published>
    <updated>2018-05-14T02:29:03.731Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉koa库的都知道,他的核心是koa-compose</p><p>以前也看过这个库,实现的很巧妙,但是老是看了就忘,今天在这里记录一下</p><a id="more"></a><p>koa-conmpose的代码只有短短一二十行,电脑屏幕一屏就可以装下,但是他却有非常强大的功能</p><p>这个组件是在koa/application里面被调用<br>调用的时机是调用app.listen的时候,<br>app.listen调用的是http模块的createServer方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">   debug(<span class="string">'listen'</span>);</span><br><span class="line">   <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">   <span class="keyword">return</span> server.listen(...args);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这个文件的调用就是在this.callback()里面<br>callback返回的是初始化了上下文,并执行了中间件的函数<br>与之有关的函数是this.handleRequest()和respond</p><p>在说回koa-compose插件</p><p><em>他首先传入的是一个中间价数组</em></p><p>是在执行this.callback()的时候的时候传入的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br></pre></td></tr></table></figure></p><p>this.middleware数组是在调用app.use的时候加入进去的,一系列的处理事件</p><p>koa-compose获取到这个数组以后,会首先对数组进行检查,首先检查是不是数组,然后检查数组里面的元素是不是函数.</p><p><em>检查完后会返回一个函数,</em><br><em>这个函数的形参是一个ctx上下文,和一个next指针</em></p><p>这个函数主要是循环middleware里的每一项,执行每一个函数</p><p>将函数变为promise函数</p><p>然后在成功的时候执行当前函数,并开始下一个函数,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(fn(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dispatch(i + <span class="number">1</span>)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>这里应该是插件的核心,执行middleware的时候,传入上下文,然后当中间件调用next的时候,就执行下一个函数<br><strong>因为js是单线程!!!所以当执行next的时候会开一个新的执行上下文</strong><br><strong>所以next后面的代码不会去执行,会执行next里的代码</strong><br><strong>等next里代码执行结束,退出执行上下文,在执行next后面的代码</strong><br><strong>这就实现了koa洋葱图!!!</strong></p><p>next前代码   —按照js执行顺序执行</p><p>next()      —-开辟一个新的执行上下文,js流程阻塞  </p><p>next后代码  —-next()里代码执行完成,执行next后代码</p><p>当所有中间件执行完成以后,然后将它返回回去</p><p>然后进入respond函数去判断ctx的状态,到此就结束.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟悉koa库的都知道,他的核心是koa-compose&lt;/p&gt;
&lt;p&gt;以前也看过这个库,实现的很巧妙,但是老是看了就忘,今天在这里记录一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="koa koa-compose" scheme="http://www.gmkgmk.com/tags/koa-koa-compose/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置记录</title>
    <link href="http://www.gmkgmk.com/2018/05/13/nginx%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.gmkgmk.com/2018/05/13/nginx配置记录/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2018-05-13T11:23:21.779Z</updated>
    
    <content type="html"><![CDATA[<p>最近个人网站的nginx因为需要增加了一些配置,在这里简单的记录一下.</p><p>个人对nginx并不熟悉,以前映射博客域名也只是简单了解一下,这里相当于一个学习的基础整理</p><h3 id="新增配置的目的"><a href="#新增配置的目的" class="headerlink" title="新增配置的目的"></a>新增配置的目的</h3><ul><li>新增聊天室映射,即当访问<code>/room</code>路劲是访问聊天室的路劲</li><li>http与https都能访问</li><li>访问端口的时候可以代理请求</li><li>静态资源路径处理</li></ul><a id="more"></a><p>原有的功能:</p><ul><li>http与https映射端口代理博客域名</li></ul><h3 id="nginx基本命令"><a href="#nginx基本命令" class="headerlink" title="nginx基本命令"></a>nginx基本命令</h3><p>因为是在个人服务器上进行配置,所以会有一些基本的nginx操作</p><p>不同的操作系统不一样,我的是centos7</p><ul><li>whereis nginx 寻找nginx的位置,我的是在/etc/nginx下</li><li>nginx -t 检查nginx文件是否有错误</li><li>nginx -s reload 重启nginx</li></ul><h3 id="nginx配置详情"><a href="#nginx配置详情" class="headerlink" title="nginx配置详情"></a>nginx配置详情</h3><p>进入你的配置文件后,可以先设置两个变量名,这个和js一样,也就是为了方便管理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream blog&#123;</span><br><span class="line">server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3000</span>;</span><br><span class="line">&#125;</span><br><span class="line">upstream egg&#123;</span><br><span class="line">server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">7001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个变量分别对应本机不同的端口</p><p>首先来看一下http的服务配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">server_name <span class="number">198.13</span><span class="number">.35</span><span class="number">.167</span> www.gmkgmk.com;<span class="comment">//监听的ip</span></span><br><span class="line">listen <span class="number">80</span>;<span class="comment">//监听的端口</span></span><br><span class="line">    location / &#123;<span class="comment">//访问根目录:/ 这是访问博客的配置</span></span><br><span class="line">    proxy_pass http:<span class="comment">//blog;    //代理的是变量里边blog的变量</span></span><br><span class="line">      proxy_set_header   Host $host;</span><br><span class="line">      proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">      proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">   &#125;</span><br><span class="line">location /room &#123; <span class="comment">//监听的路劲,如果是www.gmkgmk.com/room就走这里</span></span><br><span class="line">alias   /home/chatRoom/www/;             <span class="comment">//映射的文件夹路径</span></span><br><span class="line">try_files $uri $uri/ <span class="regexp">/index.html =404;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">location /</span>www &#123; <span class="comment">//处理静态资源,因为访问静态资源的路径全是 /www/abc.css</span></span><br><span class="line">location ~* \.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ &#123;</span><br><span class="line">root   /home/chatRoom;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">location /v2 &#123; <span class="comment">//代理端口,没有进行特殊处理</span></span><br><span class="line">proxy_pass http:<span class="comment">//egg;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">    location = <span class="regexp">/50x.html &#123;</span></span><br><span class="line"><span class="regexp">        alias   /</span>home/chatRoom/www/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是基本的配置;<br>访问www.gmkgmk.com的时候就会直接访问 127.0.0.1:3000<br>访问www.gmkgmk.com/room的时候就会直接访问 /home/chatRoom/www/ 路径<br>访问www.gmkgmk.com/www/abc.css目录的时候就会访问/home/chatRoom/www/abc.css<br>访问www.gmkgmk.com/v2/getList端口就等于访问127.0.0.1:7001/getList接口</p><p>值得注意的是/room这个的配置<br>访问路径有两种一个是alias,另一个是root.<br>alias别名:也就是访问/room就是到/home/chatRoom/www/<br>root根:访问/room就是到/home/chatRoom/www/room</p><p>这两个会有蛮多坑</p><p>还有就是处理静态资源的时候要根据自己的需求进行处理<br>配置了一次以后基本就没有什么难点了,<br>可以先在本地windows上下个nginx先根据需要配置下然后传上去</p><p>下面贴一下https的,基本上差不多.就不过多赘述了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen <span class="number">443</span> default_server  ssl;</span><br><span class="line">        server_name www.gmkgmk.com; #填写绑定证书的域名</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /etc/nginx/conf.d/gmkgmk.com/1_www.gmkgmk.com_bundle.crt;#路径填写自己的</span><br><span class="line">        ssl_certificate_key /etc/nginx/conf.d/gmkgmk.com/2_www.gmkgmk.com.key;#路径填写自己的</span><br><span class="line">        ssl_session_timeout <span class="number">5</span>m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        location / &#123;</span><br><span class="line">           proxy_set_header Host  $http_host;</span><br><span class="line">           proxy_set_header X-Real-IP  $remote_addr;  </span><br><span class="line">           proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">           proxy_set_header X-Nginx-proxy <span class="literal">true</span>;</span><br><span class="line">           # 这里也要修改为你的二级域名前缀</span><br><span class="line">           proxy_pass http:<span class="comment">//blog;</span></span><br><span class="line">           proxy_redirect off;</span><br><span class="line">        &#125;</span><br><span class="line">location /room &#123;</span><br><span class="line">alias   /home/chatRoom/www/;</span><br><span class="line">try_files $uri $uri/ <span class="regexp">/index.html =404;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">location /</span>www &#123;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ &#123;</span><br><span class="line">root   /home/chatRoom;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">location /v2/ &#123;</span><br><span class="line">proxy_pass http:<span class="comment">//egg;</span></span><br><span class="line">        &#125;</span><br><span class="line">error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">location = <span class="regexp">/50x.html &#123;</span></span><br><span class="line"><span class="regexp">alias   /</span>home/chatRoom/www/;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近个人网站的nginx因为需要增加了一些配置,在这里简单的记录一下.&lt;/p&gt;
&lt;p&gt;个人对nginx并不熟悉,以前映射博客域名也只是简单了解一下,这里相当于一个学习的基础整理&lt;/p&gt;
&lt;h3 id=&quot;新增配置的目的&quot;&gt;&lt;a href=&quot;#新增配置的目的&quot; class=&quot;headerlink&quot; title=&quot;新增配置的目的&quot;&gt;&lt;/a&gt;新增配置的目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;新增聊天室映射,即当访问&lt;code&gt;/room&lt;/code&gt;路劲是访问聊天室的路劲&lt;/li&gt;
&lt;li&gt;http与https都能访问&lt;/li&gt;
&lt;li&gt;访问端口的时候可以代理请求&lt;/li&gt;
&lt;li&gt;静态资源路径处理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://www.gmkgmk.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>暂未整理,只做备份(深入浅出React和Redux学习笔记)</title>
    <link href="http://www.gmkgmk.com/2018/04/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.gmkgmk.com/2018/04/13/深入浅出React和Redux学习笔记/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-13T10:27:13.224Z</updated>
    
    <content type="html"><![CDATA[<p>connet函数的作用<br>connet作为容器组件:<br>1,把store上的状态转化为内层傻瓜组件的props,<br>2.把内层傻瓜组件中的用户动作转化为派送给Store的动作<br>一个是内层傻瓜对象的输入,一个是内层傻瓜对象的输出.<br>这两个工作的套路也很明显,吧Store上的状态转化为内层组件的props,其实就是一个映关系,去掉框架,最后就是一个mapStateToProps函数该做的事情,</p><p>mapStateToProps和mapDispatchToProps都可以包含第二个参数,代表ownProps,也就是直接传递给外层容器组件的props<br><a id="more"></a></p><p>redux按功能组织:<br><em>actionTypes.js定义action到类型;</em>action.js定义action构造函数,决定了这个功能模块可以接受的动作;<br><em>views目录,包含这个功能模块中所有的React组件,包括傻瓜组件和容器组件;</em>index.js这个文件把左右的角色导入,然后统一导出.</p><p>redux开发辅助工具<br>redux-immutable-state-invariant包,检查reducer是否违反纯函数</p><p>createStore第三个参数(storeEnhaners)<br>这个参数能够让createStore函数产生的sTore对象具有更多更强的功能;<br>如果有多个,可以通过compose将多个组合在一起;</p><p>resele库:提高数据获取性能</p><p>代理方式的高阶组件场景:<br>1,操作prop;<br>2.访问ref;<br>3.抽取状态;  —如connet函数<br>4.包装组件;</p><p>代理方式和继承方式最大的区别,是使用被包裹组件的方式.</p><p>在继承方式下,render函数中渲染被包裹组件的代码: return super.render()</p><p>代理方式下WrappedComponent经历了一个完整的生命周期,但在继承方式下super.render()只是一个生命周期中的一个函数;<br>在代理方式下产生的新组建和参数组件是两个不同的组件,一次渲染,两个组件都要经历各自的生命周期,在继承方式下两者合二为一,只有一个生命周期</p><p>继承方式的高级组件场景:<br>1.操纵prop;<br>2.操纵生命周期函数;</p><p>redux流程:<br>驱动Redux流程的是action对象,每一个action对象被派发到Store 上之后,同步地被分配给所有的reducer函数,<br>每个reducer都是纯函数,纯函数不产生任何副作用,自然是完成数据操纵之后立刻同步返回;<br>reducer返回的结果又被同步地拿去更新store上的状态数据,<br>更新状态数据的操作会立刻被同步给监听Store状态改变的函数<br>从而引发作为试图的React组件更新过程.</p><p>thunk-&gt;辅助调用另一个子程序的子程序<br>如:const f = (x) =&gt; {<br>    return x() + 5;<br>}<br>const g = () =&gt; {<br>    return 3 + 4;<br>}</p><p>f(g);</p><p>上述代码g就是一个thunk,这样使用的好处是g的执行只有在f实际执行时才执行,可以起到延迟执行的作用.</p><p>在Redux架构下,一个action对象再通过store.dispatch派发,在调用reducer函数之前,会先经过一个中间件的环节,这就是产生异步操作的机会,<br>实际上redux-thunk提供的就是一个Redux中间件,我们需要在创建Store时用上这中间件.</p><p>异步的action对象不是一个普通的js对象,而是一个函数,</p><p>如果没有redux-thunk中间件的存在,这样一个函数类型的action对象被派发出来会一路发送到各个reducer函数,<br>reducer函数从这些实际上是函数的action对象上是无法获取type字段的,所以也做不了什么实质的处理.<br>有了redux-thunk中间件之后会直接被中间件拦截<br>redux-thunk的工作室检查action对象是不是函数,如果不是函数就放行,完成普通action对象的生命周期,<br>而如果发现action对象是函数,那就执行这个函数,并把Store的dispath函数和getState函数作为参数传递到函数中去,处理过程到此为止,不会让这个异步action对象继续往前派发到reducer函数</p><p>使用中间件方法:<br>第一种方法是用Redux提供的appliMiddleware来包装createStore产生一个新的创建Store的函数.<br>中间件通过applyMiddleware包装后产生一个新的函数,新产生的函数是一个Store Enhancer.<br>然后这个函数又将Redux的createStore作为参数,产生了一个加强版的创造store函数,一般命名为configureStore<br>利用configureStore创造的Store将具有thunkMiddleware中间件的功能;</p><p>第二种方法是吧applyMiddleware的结果当做Store Enhancer,和其他的Enhancer混合之后作为createStore参数传入–利用compose函数,将多个Store Enhancer串接成一个;<br>使用这种方法一定把appliMiddleware的结果作为compose到第一个参数,因为增强器的顺序就是它们处理action对象的顺序</p><p>Store Enhancer:<br>Redux提供的创建Store的函数叫createStore,这个函数除了可以接受reducer和初始状态参数,还可以接受一个Store Enhancer作为参数<br>Store Enhancer是一个函数,这个函数接受一个createStore模样的函数为参数,返回一个新的createStore函数.</p><p>一个什么都不做的 Store Enhancer长的这个样子:<br>const doNothingEnhancer = (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt;{<br>    const store = createStoe(reducer, preloadedState, enhancer);<br>    return store;<br>}</p><p>实现一个Store Enhancer,功夫全在于如何定制生产的store对象.<br>一个store 对象中包含下列接口:<br>dispatch,<br>subscribe<br>getState<br>replaceReducer<br>每一个接口都可以被修改,但是不论怎么修改,往往还是要调用原有对应的函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;connet函数的作用&lt;br&gt;connet作为容器组件:&lt;br&gt;1,把store上的状态转化为内层傻瓜组件的props,&lt;br&gt;2.把内层傻瓜组件中的用户动作转化为派送给Store的动作&lt;br&gt;一个是内层傻瓜对象的输入,一个是内层傻瓜对象的输出.&lt;br&gt;这两个工作的套路也很明显,吧Store上的状态转化为内层组件的props,其实就是一个映关系,去掉框架,最后就是一个mapStateToProps函数该做的事情,&lt;/p&gt;
&lt;p&gt;mapStateToProps和mapDispatchToProps都可以包含第二个参数,代表ownProps,也就是直接传递给外层容器组件的props&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://www.gmkgmk.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>学习源码之promise</title>
    <link href="http://www.gmkgmk.com/2018/03/09/%E5%AD%A6%E4%B9%A0%E6%BA%90%E7%A0%81%E4%B9%8Bpromise/"/>
    <id>http://www.gmkgmk.com/2018/03/09/学习源码之promise/</id>
    <published>2018-03-09T14:41:00.000Z</published>
    <updated>2018-03-14T03:05:56.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习源码之promise"><a href="#学习源码之promise" class="headerlink" title="学习源码之promise;"></a>学习源码之promise;</h1><p>promise代码库应该是目前为止能看懂的很简单的库,但是确是我们日常开发中经常使用到的.</p><p>我们使用promise时常常会这样使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise_test = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      resolve(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise_test.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>很明显的就是通过一个构造函数,然后使用一个回调,回调里的有两个方法形参,通过调用不同方法形参来处理状态;</p><p>通过源码查看,其实原理并不难;</p><h1 id="一-初始化"><a href="#一-初始化" class="headerlink" title="一.初始化"></a>一.初始化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promises must be constructed via new'</span>);</span><br><span class="line">    &#125; <span class="comment">//判断是不是通过构造函数生成的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promise constructor\'s argument is not a function'</span>);</span><br><span class="line">    &#125;<span class="comment">//判断构造函数的参数是不是一个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化promise对象的状态</span></span><br><span class="line">    <span class="keyword">this</span>._deferredState = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>._state = <span class="number">0</span>;<span class="comment">//当前的状态</span></span><br><span class="line">    <span class="keyword">this</span>._value = <span class="literal">null</span>;<span class="comment">//执行的值</span></span><br><span class="line">    <span class="keyword">this</span>._deferreds = <span class="literal">null</span>; <span class="comment">//递归的对象</span></span><br><span class="line">    <span class="keyword">if</span> (fn === noop) <span class="keyword">return</span>; <span class="comment">//function noop() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化以后传入doResolve函数进行处理</span></span><br><span class="line">    doResolve(fn, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化第一次调用的状态</span></span><br><span class="line">  <span class="built_in">Promise</span>._onHandle = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">Promise</span>._onReject = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">Promise</span>._noop = noop;</span><br></pre></td></tr></table></figure><p>每次new Promise就会去创建一个新的promise对象,这个对象的作用在初始化的作用就是<br><strong>初始化值和将当前对象和传入的函数传给doResolve函数(相当于函数处理器)进行处理</strong></p><p>再看看简化后的doResolve函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">doResolve(fn, promise) &#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line">  fn(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.resolve(promise, value);</span><br><span class="line">  &#125;, (reason) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.reject(promise, reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fn就是</span></span><br><span class="line">(resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      resolve(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>done的作用是防止执行两个回调;</p><p>这部分根据你选择的状态执行成功还是失败的回调;</p><p><strong>所以这是初始化的最后一步;</strong></p><p>因为是异步操作,如例是一个定时器(函数请求也一样),我们知道,定时器会在一定时间后加入队列,<br>达到时间后执行里面的函数<br><strong>所以就会在1000毫秒以后执行resolve(“hello”)这段函数</strong><br><strong>resolve有是new promise的时候的参数,就相当于回去调用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (done) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">this</span>.resolve(promise, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会将promise对象和定时器resolve时候传入的参数传给this.resolve函数(一个开关的作用,开始执行队列)</p><p>初始化部分就这样,也是因为这一部分,所以new promise里的函数是同步,而this.resolve里的函数是异步,因为this.resolve的时候才会开始下面的工作!</p><h1 id="加入then执行队列"><a href="#加入then执行队列" class="headerlink" title="加入then执行队列"></a>加入then执行队列</h1><p>then队列就在new promise后.then就加入队列,但是是在异步流程(如上例的定时器和ajax请求)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略其他情况</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Promise</span>(noop); <span class="comment">//function noop() &#123;&#125;</span></span><br><span class="line">  handle(<span class="keyword">this</span>, <span class="keyword">new</span> Handler(onFulfilled, onRejected, res));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>then的作用就是生成一个promise对象(<strong>每次then都是建立一个新的promise对象</strong>),<br>然后调用handle函数,将当前promise对象和Handler传入<br>Handler是为了处理当前是函数是成功还是失败的</p><p>return res是为了能执行链式操作所有返回当前promise对象</p><p><strong>注意返回的是新建立的promise对象,而不是初始化的,所以每次返回的都是一个新的promise</strong></p><p>先看看Handler函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Handler</span>(<span class="params">onFulfilled, onRejected, promise</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.promise = promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就判断是成功还是失败的状态,然后传入一个新的promise,把当前的promise保存起来</p><p>接下来handle</p><p><strong>这是promise的一个重要函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handle(self, deferred) &#123;</span><br><span class="line"> <span class="comment">//  ...省略其他情况</span></span><br><span class="line">   <span class="keyword">if</span> (self._state === <span class="number">0</span>) &#123;</span><br><span class="line">     self._state = <span class="number">1</span></span><br><span class="line">     self._deferreds = deferred;</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.handleResolved(self, deferred)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个函数只看一般正常情况</p><p>传入的self是当前promise对象;<br>传入的deferred是一个promise对象,和then的成功或者失败的回调;</p><p>当一进来的时候_state是0,说明他正在初始化状态,没有进入队列;<br>所以改变他的状态为1,说明加入队列,<br><strong>重点</strong><br><strong>然后将当前的_deferreds属性设置为deferred(也是一个promise)</strong><br>就是把then里面的回调函数保存在初始化的promise的_deferreds属性里面;</p><p>注意这个时候是return了,并不会执行this.handleResolved(self, deferred)这个函数;</p><p><strong>按道理then到这里就结束了,但是这个还是想多提示一下Promise.prototype.then函数里return 的是一个新的promise,而这</strong><br><strong>个promise对象通过Handle包装后保存在当前promise的_deferreds里面</strong></p><p>也就是说a._deferreds是一个Handle函数(onFulfilled,onRejected,promise)</p><p>也就是说a._deferreds.promise是一个promise.</p><p>如果有多个then的话,下一个就会保存在a._deferreds.promise 的 _deferreds里面,就形成一个递归队列</p><p>this.handleResolved(self, deferred)在then的时候并不会调用,这段是执行的时候的函数,到时候再说;</p><h1 id="三-执行函数"><a href="#三-执行函数" class="headerlink" title="三.执行函数"></a>三.执行函数</h1><p>当异步流程(如上例的定时器和ajax请求)结束以后,就会根据状态执行 this.resolve者this.reject函数;</p><p>主要就是根据不同的状态设置不同的_status值,然后调用finale函数;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self._state = <span class="number">1</span>;<span class="comment">//2,3</span></span><br><span class="line">self._value = newValue;</span><br><span class="line"><span class="keyword">this</span>.finale(self);</span><br></pre></td></tr></table></figure><p>finale函数就是根据不用的_deferredState状态判断是否循环执行,这里只取正常状态;</p><p>然后又进入到刚才handle函数</p><p>执行完成以后会将当前的_deferreds给销毁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finale(self) &#123;</span><br><span class="line">  handle(self, self._deferreds);</span><br><span class="line">  self._deferreds = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经讲过handle函数,是根据_status判断状态,</p><p>这里是已经通过异步队列的函数,在this.resolve者this.reject函数函数里改变为了1,直接就会执行handleResolved函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">self, deferred</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//就会直接执行handleResolved函数...</span></span><br><span class="line">  handleResolved(self, deferred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一看最后一步handleResolved函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResolved</span>(<span class="params">self, deferred</span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cb = self._state === <span class="number">1</span> ? deferred.onFulfilled : deferred.onRejected;</span><br><span class="line">    <span class="keyword">if</span> (cb === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (self._state === <span class="number">1</span>) &#123;</span><br><span class="line">        resolve(deferred.promise, self._value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(deferred.promise, self._value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ret = tryCallOne(cb, self._value);</span><br><span class="line">    <span class="keyword">if</span> (ret === IS_ERROR) &#123;</span><br><span class="line">      reject(deferred.promise, LAST_ERROR);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(deferred.promise, ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 个人简化版</span></span><br><span class="line">  <span class="keyword">var</span> cb = deferred.onFulfilled || deferred.onRejected || <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> res = cb(self._value);</span><br><span class="line">  <span class="keyword">if</span>(self._state===<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.resolve(deferred.mypromise, res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一进去根据他的_state判断是否有相应的处理函数,如果没有相应的处理函数,就跳过,又去执行resolve或者reject</p><p>如果有相应的函数,就执行var ret = tryCallOne(cb, self._value);</p><p>就相相当于把当前的value传入处理函数,并执行,获取返回值;</p><p>再将当前函数保存的deferred的promise对象和返回值一起传入resolve在进行递归;</p><p>初始化的时候:</p><p>初始化的promise                  —初始化的promise函数,等待异步队列结束后执行<br>  _deferred.onFulfilled          —then的时候保存成功或者失败的回调<br>  _deferred.onRejected<br>  _deferred.promise              —then的时候将一个新的promise加入上一个的 _deferred中<br>            _deferred.onFulfilled<br>            _deferred.onRejected<br>            _deferred.promise             </p><p>执行的时候:<br>   <strong>执行的时候会在成功或者失败的回调中保存_value,然后在handleResolved中调用回调的时候传入</strong></p><p>执行的promise<br>  _deferred.onFulfilled          —执行时候执行成功或者失败的回调,然后获取返回值,<br>  _deferred.onRejected<br>  _deferred.promise              —然后执行promise队列,直到结束</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习源码之promise&quot;&gt;&lt;a href=&quot;#学习源码之promise&quot; class=&quot;headerlink&quot; title=&quot;学习源码之promise;&quot;&gt;&lt;/a&gt;学习源码之promise;&lt;/h1&gt;&lt;p&gt;promise代码库应该是目前为止能看懂的很简单的库,但是确是我们日常开发中经常使用到的.&lt;/p&gt;
&lt;p&gt;我们使用promise时常常会这样使用&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; promise_test = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    () =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resolve(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;promise_test.then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(res)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(res)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(res)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(res)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="promise js" scheme="http://www.gmkgmk.com/tags/promise-js/"/>
    
  </entry>
  
  <entry>
    <title>查漏补缺之JSON字符串化</title>
    <link href="http://www.gmkgmk.com/2018/03/09/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%E4%B9%8BJSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%96/"/>
    <id>http://www.gmkgmk.com/2018/03/09/查漏补缺之JSON字符串化/</id>
    <published>2018-03-09T14:40:00.000Z</published>
    <updated>2018-03-14T03:06:24.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查漏补缺之JSON字符串化"><a href="#查漏补缺之JSON字符串化" class="headerlink" title="查漏补缺之JSON字符串化"></a>查漏补缺之JSON字符串化</h1><h2 id="JSON的转化"><a href="#JSON的转化" class="headerlink" title="JSON的转化"></a>JSON的转化</h2><p>通常,我们将一个JSON转换为字符串的时候,会用到 JSON.stringify的方法;</p><p>对于大多数值来说,用 JSON.stringify和toString()并没有什么差别;</p><p>所有安全的值都可以被这个方法转化为字符串(安全得值是指JSON值能够呈现为有效的JSON各式的值)</p><p>不安全得值大概包括:undefined,function,symbol,包含循环引用;都无法通过这个函数处理;</p><p>当要对这些值进行处理的时候,就可以在对象中定义名为toJSON()的方法来返回一个安全的JSON值;</p><p><em>toJSON能够’返回一个能够被字符串化的安全的JSON值’</em><br><a id="more"></a></p><p><strong>也就是说会使用JSON.stringify的时候,如果JSON离包含有一个叫做toJSON的方法,则会先执行这个方法,根据方法里所指定的规制,讲不安全的值转换为安全的值,再进行stringify转化</strong></p><h2 id="JSON-stringify的几个参数"><a href="#JSON-stringify的几个参数" class="headerlink" title="JSON.stringify的几个参数"></a>JSON.stringify的几个参数</h2><p>我们一般使用JSON.stringify会使用他的第一个参数,但是他还有一些参数很实用;</p><p>JSON.stringify(json,replacer,space)</p><h3 id="可选参数replacer"><a href="#可选参数replacer" class="headerlink" title="可选参数replacer"></a>可选参数replacer</h3><p><em>他可以是一个数组或者函数</em><br>用来制定对象序列化过程中哪些属性应该被处理,哪些应该被排除;和toJSON很像;</p><p><strong>当replacer是一个数组的时候:</strong></p><p>那么他必须是一个字符串数组,其中包含序列化要处理的对象的属性名称,除了数组里的属性名称,其他属性在转化的时候都将被忽略;</p><p><strong>当replacer时一个函数的时候:</strong></p><p>他会对对象本身调用一次,然后对对象中的每个属性各调用一次,每次传递两个参数,键和值.如要要忽略某个参数就返回undefined,否者返回制定的值;</p><p><strong>第一次调用因为是对对象调用,所以第一次调用的键值会是undefined</strong><br><strong>字符串化是递归的,他会循环对象中的每一项</strong><br><strong>如果需要处理的对象中有数组,使用函数调用时,键值是他在数组中的位置</strong></p><h3 id="可选参数space"><a href="#可选参数space" class="headerlink" title="可选参数space"></a>可选参数space</h3><p>用来指定输出的缩进格式.<br>space是正数时是指定每一级缩进的字符数,他也可以是字符串;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查漏补缺之JSON字符串化&quot;&gt;&lt;a href=&quot;#查漏补缺之JSON字符串化&quot; class=&quot;headerlink&quot; title=&quot;查漏补缺之JSON字符串化&quot;&gt;&lt;/a&gt;查漏补缺之JSON字符串化&lt;/h1&gt;&lt;h2 id=&quot;JSON的转化&quot;&gt;&lt;a href=&quot;#JSON的转化&quot; class=&quot;headerlink&quot; title=&quot;JSON的转化&quot;&gt;&lt;/a&gt;JSON的转化&lt;/h2&gt;&lt;p&gt;通常,我们将一个JSON转换为字符串的时候,会用到 JSON.stringify的方法;&lt;/p&gt;
&lt;p&gt;对于大多数值来说,用 JSON.stringify和toString()并没有什么差别;&lt;/p&gt;
&lt;p&gt;所有安全的值都可以被这个方法转化为字符串(安全得值是指JSON值能够呈现为有效的JSON各式的值)&lt;/p&gt;
&lt;p&gt;不安全得值大概包括:undefined,function,symbol,包含循环引用;都无法通过这个函数处理;&lt;/p&gt;
&lt;p&gt;当要对这些值进行处理的时候,就可以在对象中定义名为toJSON()的方法来返回一个安全的JSON值;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;toJSON能够’返回一个能够被字符串化的安全的JSON值’&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://www.gmkgmk.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>小程序学习</title>
    <link href="http://www.gmkgmk.com/2018/01/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.gmkgmk.com/2018/01/12/小程序学习/</id>
    <published>2018-01-12T02:40:00.000Z</published>
    <updated>2018-03-14T03:06:14.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><h2 id="一-录音相关"><a href="#一-录音相关" class="headerlink" title="一.录音相关"></a>一.录音相关</h2><p>wx.getRecorderManager()</p><p><strong>全局唯一</strong>的录音管理器</p><p>四个方法:start(参数:options),pause,resume,stop;</p><p>三个监听方法:onStart,onPause,onStop; –(参数:callback)</p><p>其他事件:onFrameRecorded,onError; –(参数:callback)<br><a id="more"></a></p><h3 id="1-开始录音"><a href="#1-开始录音" class="headerlink" title="1. 开始录音"></a>1. 开始录音</h3><p>recorderManager.start(option)</p><p>start(options) 说明：<br><img src="/images/wx/recorder_1.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">startRecord() &#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    duration: <span class="number">10000</span>, <span class="comment">//录音时长</span></span><br><span class="line">    sampleRate: <span class="number">44100</span>, <span class="comment">//采样率</span></span><br><span class="line">    numberOfChannels: <span class="number">1</span>,<span class="comment">//录音通道</span></span><br><span class="line">    encodeBitRate: <span class="number">192000</span>,<span class="comment">//编码码率</span></span><br><span class="line">    format: <span class="string">"aac"</span><span class="comment">//音频格式，有效值 aac/mp3</span></span><br><span class="line">  &#125;;</span><br><span class="line">  recorderManager.start(options);</span><br><span class="line">  recorderManager.onStart(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"recorder start"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  recorderManager.onError(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-停止录音"><a href="#2-停止录音" class="headerlink" title="2. 停止录音"></a>2. 停止录音</h3><p>recorderManager.stop(callback)</p><p>参数:callBack 返回参数 tempFilePath String 录音文件的临时路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stopRecord() &#123;</span><br><span class="line">  recorderManager.stop();</span><br><span class="line">  recorderManager.onStop(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      recorderFile: res</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"停止录音"</span>, res.tempFilePath);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="3-录音管理"><a href="#3-录音管理" class="headerlink" title="3. 录音管理"></a>3. 录音管理</h3><p>音频组件管理:</p><p>wx.createInnerAudioContext()</p><p><em>创建并返回内部 audio 上下文 innerAudioContext 对象</em></p><p>innerAudioContext 的属性:</p><p><img src="/images/wx/recorder_2.png" alt=""></p><p>innerAudioContext 的方法</p><p>五个方法:play,pause,stop,seek(position:单位 s),destroy;</p><p>对应监控:onPlay,onPause,onStop,onSeeking,onSeeked;</p><p>其他:onCanplay(可以开始),onEnded(自然结束),onTimeUpdate(进度条更新),onError,onWaiting(数据不足时加载)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">playRecord() &#123;</span><br><span class="line">  <span class="comment">// 创建audio上下文</span></span><br><span class="line">  <span class="keyword">const</span> innerAudioContext = wx.createInnerAudioContext();</span><br><span class="line">  innerAudioContext.src = <span class="keyword">this</span>.data.recorderFile.tempFilePath; <span class="comment">//设置路径this.data.recorderFile.tempFilePath为String 音频的地址;</span></span><br><span class="line"></span><br><span class="line">  innerAudioContext.play(); <span class="comment">//开始播放</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行周期监控</span></span><br><span class="line">  innerAudioContext.onPlay(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"调用一次"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  innerAudioContext.onCanplay(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"进入播放状态"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  innerAudioContext.onEnded(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"音频自然播放结束"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  innerAudioContext.onError(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  innerAudioContext.destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tip：一个小程序内最多只能存在-5-个-innerAudio-实例"><a href="#tip：一个小程序内最多只能存在-5-个-innerAudio-实例" class="headerlink" title="tip：一个小程序内最多只能存在 5 个 innerAudio 实例"></a>tip：一个小程序内最多只能存在 5 个 innerAudio 实例</h2><p>(所以应该要及时销毁?)</p><h2 id="二-上传下载文件"><a href="#二-上传下载文件" class="headerlink" title="二.上传下载文件"></a>二.上传下载文件</h2><h3 id="1-上传文件"><a href="#1-上传文件" class="headerlink" title="1. 上传文件"></a>1. 上传文件</h3><p>wx.uploadFile(OBJECT)</p><p>首先是选择图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chooseImg() &#123;</span><br><span class="line">  wx.chooseImage(&#123;</span><br><span class="line">    count: <span class="number">1</span>, <span class="comment">// 默认9</span></span><br><span class="line">    sizeType: [<span class="string">"original"</span>,<span class="string">"compressed"</span>], <span class="comment">// 可以指定是原图还是压缩图，默认二者都有</span></span><br><span class="line">    sourceType: [<span class="string">"album"</span>, <span class="string">"camera"</span>], <span class="comment">// 可以指定来源是相册还是相机，默认二者都有</span></span><br><span class="line">    success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片</span></span><br><span class="line">      <span class="keyword">var</span> tempFilePaths = res.tempFilePaths;</span><br><span class="line">      <span class="keyword">this</span>.upload(<span class="keyword">this</span>, tempFilePaths);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>选择后获取到文件的地址</p><p>上传文件类似于 jQuery Ajax 请求;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uploadTask = wx.uploadFile(&#123;</span><br><span class="line">  url: url, <span class="comment">//上传的网址</span></span><br><span class="line">  filePath: fileSrc, <span class="comment">//文件地址</span></span><br><span class="line">  name: <span class="string">"avatar"</span>,</span><br><span class="line">  header: &#123;</span><br><span class="line">    <span class="comment">//HTTP 请求 Header，header 中不能设置 Referer</span></span><br><span class="line">    session_token: <span class="string">"12345679999"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  formData: &#123;</span><br><span class="line">    <span class="comment">// 另外的信息</span></span><br><span class="line">    user: <span class="string">"test"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function">(<span class="params">res, statusCode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.statusCode != <span class="number">200</span>) &#123;</span><br><span class="line">      wx.showModal(&#123;</span><br><span class="line">        title: <span class="string">"提示"</span>,</span><br><span class="line">        content: <span class="string">"上传失败"</span>,</span><br><span class="line">        showCancel: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    page.setData(&#123;</span><br><span class="line">      <span class="comment">//上传成功修改显示头像</span></span><br><span class="line">      src: fileSrc</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"完成"</span>);</span><br><span class="line">    page.setData(&#123;</span><br><span class="line">      progress: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>wx.uploadFile 返回一个 uploadTask 对象，通过 uploadTask，可监听上传进度变化事件，以及取消上传任务。</p><p>有两个方法:onProgressUpdate,abort</p><p>onProgressUpdate 返回参数:progress(上传百分比),totalBytesSent(已上传数据),要上传的总数据(totalBytesExpectedToSend)</p><h4 id="监控上传进度"><a href="#监控上传进度" class="headerlink" title="监控上传进度"></a>监控上传进度</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uploadTask.onProgressUpdate(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; totalBytesSent, totalBytesExpectedToSend &#125; = res;</span><br><span class="line">  <span class="keyword">const</span> percent = <span class="built_in">Math</span>.trunc(totalBytesSent / totalBytesExpectedToSend * <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    <span class="comment">//设置上传的进度</span></span><br><span class="line">    percent</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">uploadTask.abort(); <span class="comment">// 取消上传任务</span></span><br></pre></td></tr></table></figure><h3 id="2-下载文件"><a href="#2-下载文件" class="headerlink" title="2. 下载文件"></a>2. 下载文件</h3><p>wx.downloadFile(OBJECT)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">downFile() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url &#125; = <span class="keyword">this</span>.data;</span><br><span class="line">  wx.downloadFile(&#123;</span><br><span class="line">    url: url + <span class="string">"/test.jpg"</span>,</span><br><span class="line">    success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">      <span class="comment">// 只要服务器有响应数据，就会把响应内容写入文件并进入 success 回调，业务需要自行判断是否下载到了想要的内容</span></span><br><span class="line">      <span class="keyword">if</span> (res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          src: res.tempFilePath</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h3><p>1.uploadFile、downloadFile 的最大并发限制是 10 个;</p><p>2.网络请求的 referer header 不可设置。其格式固定为 <a href="https://servicewechat.com/{appid}/{version}/page-frame.html，其中" target="_blank" rel="external">https://servicewechat.com/{appid}/{version}/page-frame.html，其中</a> {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0 表示为开发版、体验版以及审核版本，版本号为 devtools 表示为开发者工具，其余为正式版本。</p><p>3.只要成功接收到服务器返回，无论 statusCode 是多少，都会进入 success 回调。请开发者根据业务逻辑对返回值进行判断。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小程序&quot;&gt;&lt;a href=&quot;#小程序&quot; class=&quot;headerlink&quot; title=&quot;小程序&quot;&gt;&lt;/a&gt;小程序&lt;/h1&gt;&lt;h2 id=&quot;一-录音相关&quot;&gt;&lt;a href=&quot;#一-录音相关&quot; class=&quot;headerlink&quot; title=&quot;一.录音相关&quot;&gt;&lt;/a&gt;一.录音相关&lt;/h2&gt;&lt;p&gt;wx.getRecorderManager()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局唯一&lt;/strong&gt;的录音管理器&lt;/p&gt;
&lt;p&gt;四个方法:start(参数:options),pause,resume,stop;&lt;/p&gt;
&lt;p&gt;三个监听方法:onStart,onPause,onStop; –(参数:callback)&lt;/p&gt;
&lt;p&gt;其他事件:onFrameRecorded,onError; –(参数:callback)&lt;br&gt;
    
    </summary>
    
    
      <category term="react antd js" scheme="http://www.gmkgmk.com/tags/react-antd-js/"/>
    
  </entry>
  
  <entry>
    <title>react服务端同构渲染-(使用redux搭建)</title>
    <link href="http://www.gmkgmk.com/2017/12/26/react-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93(%E4%BA%8C)/"/>
    <id>http://www.gmkgmk.com/2017/12/26/react-服务端渲染(二)/</id>
    <published>2017-12-26T10:19:01.819Z</published>
    <updated>2017-12-26T11:18:59.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这一部分是使用-redux-进行服务端渲染"><a href="#这一部分是使用-redux-进行服务端渲染" class="headerlink" title="这一部分是使用 redux 进行服务端渲染"></a>这一部分是使用 redux 进行服务端渲染</h1><h2 id="配置服务端-webpack"><a href="#配置服务端-webpack" class="headerlink" title="配置服务端 webpack"></a>配置服务端 webpack</h2><p>用 webpack 编译服务端,配置很简单,主要是处理样式部分比较麻烦,获取数据这部分很简单.</p><p>做了一下注释方便阅读</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  target: <span class="string">"node"</span>, <span class="comment">//target搭建目标 node会吧代码编译为类nodejs环境(使用require 而不是其他来加载chunk)</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    server: paths.serverJs <span class="comment">//server/app.js</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: paths.serverDist, <span class="comment">//build</span></span><br><span class="line">    filename: <span class="string">"bundle.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [webpackNodeExternals()],</span><br><span class="line">  node: &#123;</span><br><span class="line">    <span class="comment">//打包后的代码__filename和__dirname全部会编译成 '/' 因为这两个变量在webpack中做了一些自定义处理,所以禁用他们</span></span><br><span class="line">    __dirname: <span class="literal">false</span>,</span><br><span class="line">    __filename: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [<span class="string">"node_modules"</span>, <span class="string">"static"</span>],</span><br><span class="line">    extensions: [<span class="string">"*"</span>, <span class="string">".js"</span>, <span class="string">".json"</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      src: paths.srcPath, <span class="comment">//src</span></span><br><span class="line">      <span class="keyword">static</span>: paths.staticPath <span class="comment">//static</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        enforce: <span class="string">"pre"</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">"babel-loader"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h3 id="服务器端获取数据"><a href="#服务器端获取数据" class="headerlink" title="服务器端获取数据"></a>服务器端获取数据</h3><p>服务端渲染怎么获取数据是一个比较麻烦的问题,刚开始的时候比较迷茫,后来在网上选择后决定通过 react-router 来进行服务端数据获取;</p><p>主要是利用 router 里 loadData 的方法和他所提供的 matchPath</p><p>将获取数据的操作放在 loadData 里面,然后在服务端通过 matchPath 来判断当前路由是否有 loadData 方法,然后执行 loadData 方法来获取数据;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;这一部分是使用-redux-进行服务端渲染&quot;&gt;&lt;a href=&quot;#这一部分是使用-redux-进行服务端渲染&quot; class=&quot;headerlink&quot; title=&quot;这一部分是使用 redux 进行服务端渲染&quot;&gt;&lt;/a&gt;这一部分是使用 redux 进行服务端渲染&lt;/
      
    
    </summary>
    
    
      <category term="react ssr" scheme="http://www.gmkgmk.com/tags/react-ssr/"/>
    
  </entry>
  
  <entry>
    <title>react服务端同构渲染-(搭建react环境)</title>
    <link href="http://www.gmkgmk.com/2017/12/26/react-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93(%E4%B8%80)/"/>
    <id>http://www.gmkgmk.com/2017/12/26/react-服务端渲染(一)/</id>
    <published>2017-12-26T08:55:07.721Z</published>
    <updated>2017-12-26T10:55:19.640Z</updated>
    
    <content type="html"><![CDATA[<p>以前折腾了一段时间的 react ssr,现在总结一下,文采不好,尽量图文结合;</p><p>首先看一看现在的基本信息</p><p><img src="/images/react-ssr/catalog.png" alt=""></p><p>服务端渲染选用的是 koa 框架,因为个人比较熟悉,也可以换成其他框架,不涉及渲染的内容,也就起个简单服务器的作用;</p><p>因为会有 redux,saga,dva 三种服务端模式,所以使用的是 two package 模式,不熟悉的可以用一个就好;</p><p>首先下载依赖<br>npm install lerna koa koa-static koa-logger nodemon –save</p><p>lerna 用于 two package 模式,不需要的不用下,nodemon 用于每次修改后重新启动服务器</p><a id="more"></a><h1 id="这一部分是搭建react环境-熟悉的可以直接跳过"><a href="#这一部分是搭建react环境-熟悉的可以直接跳过" class="headerlink" title="这一部分是搭建react环境,熟悉的可以直接跳过"></a>这一部分是搭建react环境,熟悉的可以直接跳过</h1><h2 id="搭建一个后台环境"><a href="#搭建一个后台环境" class="headerlink" title="搭建一个后台环境"></a>搭建一个后台环境</h2><p>个人习惯先后台在前台,所以先搭建一个简单的 koa 服务器;</p><p>项目下面建立一个 server 文件夹,用来放服务端方面的文件;</p><p>在文件里面建立一个 app.js</p><p><img src="/images/react-ssr/appJs_1.png" alt=""></p><p>然后 node server/app.js 测试一下</p><p>成功后在 package.json 的 scripts 里添加</p><p>“start”: “nodemon app.js”</p><p>让 nodemon 自动重启 node 服务器;</p><h2 id="搭建一个-react-环境"><a href="#搭建一个-react-环境" class="headerlink" title="搭建一个 react 环境"></a>搭建一个 react 环境</h2><p>后台简单搭建后,开始搭建 react 的环境,首先使用</p><p>npm install webpack –save</p><p>因为需要 react 环境和 es6 环境,所以还需要下载 babel</p><p>npm install babel-core babel-loader babel-preset-env babel-preset-react babel-preset-stage-0 –save</p><p>然后建立 webpack 文件夹用来防止 webpack 打包数据;</p><p>配置如下,paths.cilentDist 为 public</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const paths = require("./path");</span><br><span class="line"></span><br><span class="line">const clientConfig = &#123;</span><br><span class="line">  devtool: "cheap-module-source-map",</span><br><span class="line">  target: "web",</span><br><span class="line">  entry: paths.cilentJs,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: paths.cilentDist,</span><br><span class="line">    pathinfo: true,</span><br><span class="line">    filename: "js/bundle.js"</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(js|jsx)$/,</span><br><span class="line">        enforce: "pre",</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        use: ["babel-loader"]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: ["node_modules"],</span><br><span class="line">    extensions: [".web.js", ".js", ".json", ".web.jsx", ".jsx"]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports = clientConfig;</span><br></pre></td></tr></table></figure><p>paths.cilentJs 配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Main = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;hello world React&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render(&lt;Main /&gt;, document.getElementById("root"));</span><br></pre></td></tr></table></figure><p>完成以后运行 “webpack –config webpack/webpack.client.js –watch”</p><p>会出现一个 public 文件夹,在该目录下面建立 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在打开服务器,进入 3000 端口,你会看到 not found;</p><p>因为后台没有监控静态文件</p><p>需要引用<br>app.use(koaStatic(path.join(__dirname, “..”, “public”)));</p><p>现在打开窗口,应该能见到需要的内容了</p><p>这一部分的代码在github</p><p>(<a href="https://github.com/gmkgmk/react-server-side-finishing-/releases/tag/0.1.0" target="_blank" rel="external">https://github.com/gmkgmk/react-server-side-finishing-/releases/tag/0.1.0</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前折腾了一段时间的 react ssr,现在总结一下,文采不好,尽量图文结合;&lt;/p&gt;
&lt;p&gt;首先看一看现在的基本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/react-ssr/catalog.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;服务端渲染选用的是 koa 框架,因为个人比较熟悉,也可以换成其他框架,不涉及渲染的内容,也就起个简单服务器的作用;&lt;/p&gt;
&lt;p&gt;因为会有 redux,saga,dva 三种服务端模式,所以使用的是 two package 模式,不熟悉的可以用一个就好;&lt;/p&gt;
&lt;p&gt;首先下载依赖&lt;br&gt;npm install lerna koa koa-static koa-logger nodemon –save&lt;/p&gt;
&lt;p&gt;lerna 用于 two package 模式,不需要的不用下,nodemon 用于每次修改后重新启动服务器&lt;/p&gt;
    
    </summary>
    
    
      <category term="react ssr" scheme="http://www.gmkgmk.com/tags/react-ssr/"/>
    
  </entry>
  
  <entry>
    <title>Parcel踩坑记录</title>
    <link href="http://www.gmkgmk.com/2017/12/25/Parcel%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.gmkgmk.com/2017/12/25/Parcel使用记录/</id>
    <published>2017-12-25T01:29:44.671Z</published>
    <updated>2017-12-25T01:50:08.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Parcel-踩坑记录"><a href="#Parcel-踩坑记录" class="headerlink" title="Parcel 踩坑记录"></a>Parcel 踩坑记录</h2><p>新出的打包工具 Parcel,号称是零配置,但是还是踩了不少坑,简单记录一下;</p><p>这是官网给出的速度表对比:<br><img src="/images/Parcel踩坑记录/image_1.png" alt=""><br><a id="more"></a></p><p>个人感觉 Parcel 确实速度比起 webpack 比较快,特别是加上缓存的时候,用起来很不错,还有就是自带热更新功能,很方便,他是默认以html为入口寻找引入的js,然后简析构造简析树;</p><p>其中一些地方还是需要注意一下;</p><p>使用 react+antd 的时候,babel 配置如下,需要使用 stage-0 才能使用 antd</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"browsers"</span>: [<span class="string">"last 2 Chrome versions"</span>, <span class="string">"ie &gt;= 10"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"stage-0"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [[<span class="string">"import"</span>, &#123; <span class="attr">"libraryName"</span>: <span class="string">"antd"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span> &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要注意的是在使用antd的时候使用了babel-plugin-import来进行按需加载,需要引入less来简析antd的样式否者会一直报错;</p><p>当遇到改了以后还是包一样错误的时候可以尝试先清清缓存;</p><p>总的来说还是很不错,对于一个新出的工具来说很不错,不过现在用于生产的可能性不大,还不是很完善,个人用着玩很方便,不用配置,直接下下来就可以用,对于个人开发很不错;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Parcel-踩坑记录&quot;&gt;&lt;a href=&quot;#Parcel-踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;Parcel 踩坑记录&quot;&gt;&lt;/a&gt;Parcel 踩坑记录&lt;/h2&gt;&lt;p&gt;新出的打包工具 Parcel,号称是零配置,但是还是踩了不少坑,简单记录一下;&lt;/p&gt;
&lt;p&gt;这是官网给出的速度表对比:&lt;br&gt;&lt;img src=&quot;/images/Parcel踩坑记录/image_1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Parcel 打包 踩坑" scheme="http://www.gmkgmk.com/tags/Parcel-%E6%89%93%E5%8C%85-%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>个人服务器https化</title>
    <link href="http://www.gmkgmk.com/2017/12/13/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99https%E5%8C%96/"/>
    <id>http://www.gmkgmk.com/2017/12/13/个人网站https化/</id>
    <published>2017-12-13T01:11:02.565Z</published>
    <updated>2018-03-14T05:20:37.110Z</updated>
    
    <content type="html"><![CDATA[<p>以前知道https需要证书,但是大部分都需要付费,最近在网上看到了很多不需要付费的证书,就试了一下</p><p>服务器是 vultr $5 的东京服务器,速度什么的感觉不太稳地,但能勉强使用.</p><p>需要的证书是ssl证书,我选择的是腾讯云的证书;</p><h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><hr><a id="more"></a><p>进入腾讯云官网,然后先登录,登陆后进入控制台</p><p>左上角有个云产品;</p><p><img src="/images/个人服务器https化/image_1.png" alt=""></p><p>然后点击域名与服务</p><p><img src="/images/个人服务器https化/image_2.png" alt=""></p><p>进入ssl证书管理</p><p><img src="/images/个人服务器https化/image_3.png" alt=""></p><p>然后就是个人认证什么一系列的工作,最近会让你解析域名.会给一个值,在解析的时候会用,</p><p><em>后面完全可以看帮助进行操作</em></p><h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><hr><p>解析域名我使用的是阿里云的,因为域名是阿里云买的,以前就使用过</p><p>首先进入解析域名页面;</p><p><img src="/images/个人服务器https化/image_4.png" alt=""></p><p>点击添加解析</p><p><img src="/images/个人服务器https化/image_5.png" alt=""></p><p>其他默认然后申请,等待就好.</p><p>申请下来之后下载,有个压缩包,找出里面的nginx配置</p><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><hr><p>进入自己的服务器,然后进入 /etc/nginx/conf.d/文件夹,将获取的证书放在这个文件夹里面</p><ul><li><p>1_www.gmkgmk.com_bundle.crt;</p></li><li><p>2_www.gmkgmk.com.key;</p></li></ul><p>我的配置就在这个文件夹里面,根据不同的修改就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">upstream blog&#123;</span><br><span class="line">server 127.0.0.1:3000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">server_name 198.13.35.167 www.gmkgmk.com;</span><br><span class="line">listen 80;</span><br><span class="line">        location / &#123;</span><br><span class="line">    proxy_pass http://blog;</span><br><span class="line">            proxy_set_header   Host $host;</span><br><span class="line">            proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         #上面是我个人网站的配置,下面是官网给的例子修改的</span><br><span class="line">         return 301 https://www.gmkgmk.com$request_uri; #重定向301</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name www.gmkgmk.com; #填写绑定证书的域名</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /etc/nginx/conf.d/gmkgmk.com/1_www.gmkgmk.com_bundle.crt;#路径填写自己的</span><br><span class="line">        ssl_certificate_key /etc/nginx/conf.d/gmkgmk.com/2_www.gmkgmk.com.key;#路径填写自己的</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        location / &#123;</span><br><span class="line">           proxy_set_header Host  $http_host;</span><br><span class="line">           proxy_set_header X-Real-IP  $remote_addr;  </span><br><span class="line">           proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">           proxy_set_header X-Nginx-proxy true;</span><br><span class="line">           # 这里也要修改为你的二级域名前缀</span><br><span class="line">           proxy_pass http://blog;</span><br><span class="line">           proxy_redirect off;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>检查 nginx配置:nginx -t</p><p>最后重启nginx nginx -s reload</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前知道https需要证书,但是大部分都需要付费,最近在网上看到了很多不需要付费的证书,就试了一下&lt;/p&gt;
&lt;p&gt;服务器是 vultr $5 的东京服务器,速度什么的感觉不太稳地,但能勉强使用.&lt;/p&gt;
&lt;p&gt;需要的证书是ssl证书,我选择的是腾讯云的证书;&lt;/p&gt;
&lt;h3 id=&quot;申请证书&quot;&gt;&lt;a href=&quot;#申请证书&quot; class=&quot;headerlink&quot; title=&quot;申请证书&quot;&gt;&lt;/a&gt;申请证书&lt;/h3&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="https 服务器" scheme="http://www.gmkgmk.com/tags/https-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>electron问题笔记:electron开发中遇到的问题;</title>
    <link href="http://www.gmkgmk.com/2017/12/05/electron%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
    <id>http://www.gmkgmk.com/2017/12/05/electron问题笔记(四)/</id>
    <published>2017-12-05T06:28:21.453Z</published>
    <updated>2018-01-08T03:41:12.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="electron-遇到的错误"><a href="#electron-遇到的错误" class="headerlink" title="electron 遇到的错误"></a>electron 遇到的错误</h1><hr><p>在预演过程中遇到很多坑 , 记录下 , 避免再次入坑 ;</p><h3 id="打包报错-resource-busy-or-locked-renamexxxxxxxxxxxxxxxxxxxxxxxxx"><a href="#打包报错-resource-busy-or-locked-renamexxxxxxxxxxxxxxxxxxxxxxxxx" class="headerlink" title="打包报错 :resource busy or locked, renamexxxxxxxxxxxxxxxxxxxxxxxxx"></a>打包报错 :resource busy or locked, renamexxxxxxxxxxxxxxxxxxxxxxxxx</h3><hr><p>遇到这个错误大概是因为系统正在占用这个文件夹 ,</p><ol><li><p>可以试试在任务管理器里看看这个程序有没有退出</p></li><li><p>试试 “npm cache verify” 清除缓存 ;</p></li></ol><a id="more"></a><h3 id="编译原生模块报错-“-1-is-not-a-valid-Win32-application-”-字样"><a href="#编译原生模块报错-“-1-is-not-a-valid-Win32-application-”-字样" class="headerlink" title="编译原生模块报错 : “%1 is not a valid Win32 application.” 字样"></a>编译原生模块报错 : “%1 is not a valid Win32 application.” 字样</h3><hr><p>我遇到的是打包成功 , 然后打开程序报这个错误 ;</p><p>这是因为使用的是 node 和 dll 的环境不对称 ;</p><p>在 C:\Users\user 里的 ‘.npmrc’ 修改 arch 和 target_arch 对应的版本</p><p>node 版本和 arch 和 target_arch 版本和 dll 文件的版本保持一致 , 然后运行<br>electron-rebuild, 然后再打包</p><h3 id="编译原生模块报错-“Dynamic-Linking-Error-Win32-error-193”-字样"><a href="#编译原生模块报错-“Dynamic-Linking-Error-Win32-error-193”-字样" class="headerlink" title="编译原生模块报错 : “Dynamic Linking Error: Win32 error 193” 字样"></a>编译原生模块报错 : “Dynamic Linking Error: Win32 error 193” 字样</h3><hr><p>这是 node 和 dll 文件版本不一致 , 换成一致的然后编译在打包 ;</p><h3 id="编译原生模块报错-“Dynamic-Linking-Error-Win32-error-126”-字样"><a href="#编译原生模块报错-“Dynamic-Linking-Error-Win32-error-126”-字样" class="headerlink" title="编译原生模块报错 : “Dynamic Linking Error: Win32 error 126” 字样"></a>编译原生模块报错 : “Dynamic Linking Error: Win32 error 126” 字样</h3><hr><p>这个问题困扰了我很久</p><p>网上查出来是找不到模块 , 但是 64 位都能调用成功 , 后来实验可能是 dll 文件路径问<br>题 ;</p><p>调用的文件 , 如果是绝对路径 , 就必须在当前目录下面 , 如果不是 , 必须的在打包的文<br>件夹下面 , 就是打包出来后的那个文件夹里 , 比如 dist\win-unpacked 这个文件里</p><p>其实打包的过程就是先编译文件在这个文件夹里 , 然后 build 成 exe 安装程序 , 所以这<br>里面的文件能够直接读取 ;</p><p>在 build 里配置 ;</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"extraResources": [</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">"from"</span>: <span class="string">"./aaa.DLL"</span>,</span><br><span class="line">       <span class="attr">"to"</span>: <span class="string">"../"</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">"from"</span>: <span class="string">"./bbb.dll"</span>,</span><br><span class="line">       <span class="attr">"to"</span>: <span class="string">"../"</span></span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure><p>因为文件打包出来是在 \resources 文件里面 , 所以将他提取出来 , 这样才能获取到 ;</p><p>读取的 js 文件如下 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ref = <span class="built_in">require</span>(<span class="string">"ref"</span>);</span><br><span class="line"><span class="keyword">var</span> FFi = <span class="built_in">require</span>(<span class="string">"ffi"</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> FFi.Library(<span class="string">"aaa.dll"</span>, &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="打包错误-明明是最新版本的-electron-比如-1-7-9-但是编译的时候-Packaging-for-win32-x64-using-electron-1-6-5-to-dist-win-unpacked"><a href="#打包错误-明明是最新版本的-electron-比如-1-7-9-但是编译的时候-Packaging-for-win32-x64-using-electron-1-6-5-to-dist-win-unpacked" class="headerlink" title="打包错误 : 明明是最新版本的 electron 比如 1.7.9 但是编译的时候 Packaging for win32 x64 using electron 1.6.5 to dist\win-unpacked"></a>打包错误 : 明明是最新版本的 electron 比如 1.7.9 但是编译的时候 Packaging for win32 x64 using electron 1.6.5 to dist\win-unpacked</h3><hr><p>这个错误是什么暂时还不知道 , 可以在 devDependencies 里显示下载 electon:1.7.9, 但<br>是因为的用的是 two package 模式 , 所以不可能每个都下载一次 ;</p><p>第二种方式是在 build 里面制定 electron 版本 ;</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">  "electronVersion":"1.7.9",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译报错-”fatal-error-LNK1106-invalid-file-or-disk-full”"><a href="#编译报错-”fatal-error-LNK1106-invalid-file-or-disk-full”" class="headerlink" title="编译报错:”fatal error LNK1106: invalid file or disk full”"></a>编译报错:”fatal error LNK1106: invalid file or disk full”</h3><hr><p>大概报错是这样,一大串,然后这一句开始报错,可以看看有没有这个,应该是差不多的;</p><p>原因的文件已经存在,但是又无法删除</p><p>解决的方法就是C:\Users\user 里.electron-gyp给删除了再次编译;</p><p>这个问题也不太清楚问题是什么,他是下载依赖在这个文件里,然后在进行编译;</p><p>如果网络不行可以直接从.node-gyp复制iojs-1.7.9到这个文件夹下面.</p><h3 id="运行报错-”cannot-read-property-‘webContents”-of-null"><a href="#运行报错-”cannot-read-property-‘webContents”-of-null" class="headerlink" title="运行报错:”cannot read property ‘webContents” of null"></a>运行报错:”cannot read property ‘webContents” of null</h3><p>代码有误,推出后win消失确还在执行,<br>根据代码查找错误,看哪里引用</p><h3 id="运行错误-unable-to-find-a-valid-app"><a href="#运行错误-unable-to-find-a-valid-app" class="headerlink" title="运行错误 unable to find a valid app"></a>运行错误 unable to find a valid app</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;electron-遇到的错误&quot;&gt;&lt;a href=&quot;#electron-遇到的错误&quot; class=&quot;headerlink&quot; title=&quot;electron 遇到的错误&quot;&gt;&lt;/a&gt;electron 遇到的错误&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在预演过程中遇到很多坑 , 记录下 , 避免再次入坑 ;&lt;/p&gt;
&lt;h3 id=&quot;打包报错-resource-busy-or-locked-renamexxxxxxxxxxxxxxxxxxxxxxxxx&quot;&gt;&lt;a href=&quot;#打包报错-resource-busy-or-locked-renamexxxxxxxxxxxxxxxxxxxxxxxxx&quot; class=&quot;headerlink&quot; title=&quot;打包报错 :resource busy or locked, renamexxxxxxxxxxxxxxxxxxxxxxxxx&quot;&gt;&lt;/a&gt;打包报错 :resource busy or locked, renamexxxxxxxxxxxxxxxxxxxxxxxxx&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;遇到这个错误大概是因为系统正在占用这个文件夹 ,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以试试在任务管理器里看看这个程序有没有退出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;试试 “npm cache verify” 清除缓存 ;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="electron" scheme="http://www.gmkgmk.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron问题笔记:electron使用原生模块;</title>
    <link href="http://www.gmkgmk.com/2017/11/30/electron%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
    <id>http://www.gmkgmk.com/2017/11/30/electron问题笔记(三)/</id>
    <published>2017-11-30T08:42:09.235Z</published>
    <updated>2017-12-05T07:19:01.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="electron-使用原生模块"><a href="#electron-使用原生模块" class="headerlink" title="electron 使用原生模块"></a>electron 使用原生模块</h1><hr><p>electron 使用原生模块是坑最多也是最麻烦 , 消耗时间最多的一块 , 主要是报错大多前<br>端一般不会遇到 , 经过一个多周的实验终于打包原生模块成功 , 但是因为坑实在太多 ,<br>已经有些记不起来了,先说说打包流程;</p><p>因为公司需要在 electron 打包后能够访问刷卡机 , 所以开始预演这方面的问题 ;</p><p>电脑配置 : win10 x64;</p><p>环境配置 : node 8.3 npm 5.3</p><p>这里主要说 32 位的 , 因为很多需求都是 win7x32 需要 ;</p><p>编译原生模块会使用到 node-ffi 和 ref</p><a id="more"></a><p>具体使用 node-ffi 可以参考 github, 这个没有什么坑 ;</p><p>因为编译的时候需要使用 electron-rebuild 来编译 , 这个编译比较麻烦 ;</p><p>首先配置环境 .</p><p>在 C:\Users\user 下 .npmrn 里的配置修改如下 ;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sass_binary_site=https:<span class="comment">//npm.taobao.org/mirrors/node-sass/</span></span><br><span class="line">phantomjs_cdnurl=http:<span class="comment">//npm.taobao.org/mirrors/phantomjs</span></span><br><span class="line">ELECTRON_MIRROR=http:<span class="comment">//npm.taobao.org/mirrors/electron/</span></span><br><span class="line">target=<span class="number">1.7</span><span class="number">.9</span></span><br><span class="line">arch=ia32</span><br><span class="line">target_arch=ia32</span><br><span class="line">disturl=https:<span class="comment">//atom.io/download/electron</span></span><br><span class="line">runtime=electron</span><br><span class="line">msvs_version=<span class="number">2015</span></span><br><span class="line">registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><p>arch 和 target_arch 如果是 64 位则改为 x64</p><p>因为编译 c++ 需要 vs 环境和 py 环境 , 这部分网上文章很多 , 大意是需要 py2.7x 版<br>本 , 高了不行 ,vs 环境要 c++ 的 ;</p><p>这部分开始的时候浪费了很大功夫 , 最后找到个方案很简单 . 下载 windos-build-tool<br><a href="https://github.com/felixrieseberg/windows-build-tools" target="_blank" rel="external">https://github.com/felixrieseberg/windows-build-tools</a></p><p>直接跟着安装下载就好 ; 这部分环境也很容易出错 , 但是下载完成后基本问题解决一半 ;</p><p>如果以上两点都弄好以后 , 直接进入项目目录执行 electron-rebuild 就应该会成功 ;</p><p>如果中间报什么模块找不到什么的直接下载就行</p><p>主要的就是网络 , 网络差的可能很难下下来 , 但是只是科学上网多试几次才好 ;</p><p>编译成功后就可以开始调试,打包了.</p><p>可能中间有些小坑需要网上查一查都很好找的;</p><p>在其中有几个遇到的大坑记录一下,避免以后使用时再掉坑;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;electron-使用原生模块&quot;&gt;&lt;a href=&quot;#electron-使用原生模块&quot; class=&quot;headerlink&quot; title=&quot;electron 使用原生模块&quot;&gt;&lt;/a&gt;electron 使用原生模块&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;electron 使用原生模块是坑最多也是最麻烦 , 消耗时间最多的一块 , 主要是报错大多前&lt;br&gt;端一般不会遇到 , 经过一个多周的实验终于打包原生模块成功 , 但是因为坑实在太多 ,&lt;br&gt;已经有些记不起来了,先说说打包流程;&lt;/p&gt;
&lt;p&gt;因为公司需要在 electron 打包后能够访问刷卡机 , 所以开始预演这方面的问题 ;&lt;/p&gt;
&lt;p&gt;电脑配置 : win10 x64;&lt;/p&gt;
&lt;p&gt;环境配置 : node 8.3 npm 5.3&lt;/p&gt;
&lt;p&gt;这里主要说 32 位的 , 因为很多需求都是 win7x32 需要 ;&lt;/p&gt;
&lt;p&gt;编译原生模块会使用到 node-ffi 和 ref&lt;/p&gt;
    
    </summary>
    
    
      <category term="electron" scheme="http://www.gmkgmk.com/tags/electron/"/>
    
  </entry>
  
  <entry>
    <title>electron问题笔记:使用electron-build 打包;</title>
    <link href="http://www.gmkgmk.com/2017/11/30/electron%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://www.gmkgmk.com/2017/11/30/electron问题笔记(二)/</id>
    <published>2017-11-30T07:52:40.484Z</published>
    <updated>2017-12-05T06:28:59.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="electron-问题笔记-自动升级配置"><a href="#electron-问题笔记-自动升级配置" class="headerlink" title="electron 问题笔记 : 自动升级配置"></a>electron 问题笔记 : 自动升级配置</h2><hr><p>electron-build 提供的升级方式有很多种 , 目前只预演出了 github 和 http 更新 , 不<br>过足够了 , 这两个应该是最常用的 ;</p><a id="more"></a><h2 id="通过-github-更新"><a href="#通过-github-更新" class="headerlink" title="通过 github 更新"></a>通过 github 更新</h2><hr><p>github 更新相对来说简单一点 , 而且 github 是默认的更新配置 所以我们先将 github<br>更新 , 这一部分网上资料也有很多 , 可以对比着看 , 预防记忆偏差产生的坑 ;</p><p>首先调整 main.js</p><p>这部分是参考<br><a href="https://github.com/iffy/electron-updater-example" target="_blank" rel="external">https://github.com/iffy/electron-updater-example</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow, Menu, protocol, ipcMain &#125; = <span class="built_in">require</span>(<span class="string">"electron"</span>);</span><br><span class="line"><span class="keyword">const</span> log = <span class="built_in">require</span>(<span class="string">"electron-log"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; autoUpdater &#125; = <span class="built_in">require</span>(<span class="string">"electron-updater"</span>);</span><br><span class="line">autoUpdater.logger = log;</span><br><span class="line">autoUpdater.logger.transports.file.level = <span class="string">"info"</span>;</span><br><span class="line">log.info(<span class="string">"App starting..."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> template = [];</span><br><span class="line"><span class="keyword">if</span> (process.platform === <span class="string">"darwin"</span>) &#123;</span><br><span class="line">  <span class="comment">// OS X</span></span><br><span class="line">  <span class="keyword">const</span> name = app.getName();</span><br><span class="line">  template.unshift(&#123;</span><br><span class="line">    label: name,</span><br><span class="line">    submenu: [</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"About "</span> + name,</span><br><span class="line">        role: <span class="string">"about"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        label: <span class="string">"Quit"</span>,</span><br><span class="line">        accelerator: <span class="string">"Command+Q"</span>,</span><br><span class="line">        click() &#123;</span><br><span class="line">          app.quit();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> win;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendStatusToWindow</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  log.info(text);</span><br><span class="line">  win.webContents.send(<span class="string">"message"</span>, text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDefaultWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  win = <span class="keyword">new</span> BrowserWindow();</span><br><span class="line">  win.webContents.openDevTools();</span><br><span class="line">  win.on(<span class="string">"closed"</span>, () =&gt; &#123;</span><br><span class="line">    win = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  win.loadURL(<span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/version.html#v<span class="subst">$&#123;app.getVersion()&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> win;</span><br><span class="line">&#125;</span><br><span class="line">autoUpdater.on(<span class="string">"checking-for-update"</span>, () =&gt; &#123;</span><br><span class="line">  sendStatusToWindow(<span class="string">"Checking for update..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">autoUpdater.on(<span class="string">"update-available"</span>, info =&gt; &#123;</span><br><span class="line">  sendStatusToWindow(<span class="string">"Update available."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">autoUpdater.on(<span class="string">"update-not-available"</span>, info =&gt; &#123;</span><br><span class="line">  sendStatusToWindow(<span class="string">"Update not available."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">autoUpdater.on(<span class="string">"error"</span>, err =&gt; &#123;</span><br><span class="line">  sendStatusToWindow(<span class="string">"Error in auto-updater. "</span> + err);</span><br><span class="line">&#125;);</span><br><span class="line">autoUpdater.on(<span class="string">"download-progress"</span>, progressObj =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> log_message = <span class="string">"Download speed: "</span> + progressObj.bytesPerSecond;</span><br><span class="line">  log_message = log_message + <span class="string">" - Downloaded "</span> + progressObj.percent + <span class="string">"%"</span>;</span><br><span class="line">  log_message =</span><br><span class="line">    log_message +</span><br><span class="line">    <span class="string">" ("</span> +</span><br><span class="line">    progressObj.transferred +</span><br><span class="line">    <span class="string">"/"</span> +</span><br><span class="line">    progressObj.total +</span><br><span class="line">    <span class="string">")"</span>;</span><br><span class="line">  sendStatusToWindow(log_message);</span><br><span class="line">&#125;);</span><br><span class="line">autoUpdater.on(<span class="string">"update-downloaded"</span>, info =&gt; &#123;</span><br><span class="line">  sendStatusToWindow(<span class="string">"Update downloaded"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.on(<span class="string">"ready"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> menu = Menu.buildFromTemplate(template);</span><br><span class="line">  Menu.setApplicationMenu(menu);</span><br><span class="line"></span><br><span class="line">  createDefaultWindow();</span><br><span class="line">&#125;);</span><br><span class="line">app.on(<span class="string">"window-all-closed"</span>, () =&gt; &#123;</span><br><span class="line">  app.quit();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">"ready"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  autoUpdater.checkForUpdatesAndNotify();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先需要调整你的 package;</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">         "publish": [&#123;</span><br><span class="line">             "provider": "github",</span><br><span class="line">             "repo": "https://github.com/gmkgmk/electron-up/"</span><br><span class="line">         &#125;],</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>然后通过访<br>问<a href="https://github.com/settings/tokens/new" target="_blank" rel="external">https://github.com/settings/tokens/new</a><br>来生成一个 GitHub 访问令牌。访问令牌应该具有 repo 范围 / 权限。一旦你有了令牌，<br>需要把它分配给一个环境变量</p><p>在 windows 是 , 你只需要在命令行中运行 :</p><blockquote><p>[Environment]::SetEnvironmentVariable(“GH_TOKEN”,”<your_token_here>“,”User”)</your_token_here></p></blockquote><p>这里需要修改的时候 YOUR_TOKEN_HERE</p><p>就好像[Environment]::SetEnvironmentVariable(“GH_TOKEN”,”<1234567890>“,”User”)</1234567890></p><p>设置完成后重启终端</p><p>然后开始发布 :</p><ol><li>填写 npm 里的 version, 比如 (0.0.1);</li><li>发布包 :build -p always;</li><li>通<br>过<a href="https://github.com/gmkgmk/electron-up/releases" target="_blank" rel="external">https://github.com/gmkgmk/electron-up/releases</a><br>编辑发布版本 , 编辑版本 , 然后点击发布 ;</li><li>接下来下载安装</li><li>更新 package.json 里的<em>version</em></li><li>再次执行第二步和第三步</li><li>打开程序 ;</li></ol><h2 id="通过-http-升级"><a href="#通过-http-升级" class="headerlink" title="通过 http 升级"></a>通过 http 升级</h2><hr><p>因为是公司项目 , 所以 github 发布很明显不可能满足需求 , 所以需要 http 升级</p><p>http 升级的话 ,main.js 基本上用不着改变 ,</p><p>不过有一个地方很重的就是需要使用 autoUpdater 模块的 setFeedURL</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="keyword">const</span> &#123; autoUpdater &#125; = <span class="built_in">require</span>(<span class="string">"electron-updater"</span>);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">app.on(<span class="string">"ready"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  + autoUpdater.setFeedURL(<span class="string">"http://localhost:8080"</span>);</span><br><span class="line">    autoUpdater.checkForUpdatesAndNotify();</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果使用的是 node 后台 , 要注意将 .exe 文件放在静态目录下 , 也就是让网站能够访问<br>静态资源</p><p>比如我的 koa 配置 : 就是用了一个简单的服务器 , 然后让目录在静态资源下面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server相关</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> koaStatic = <span class="built_in">require</span>(<span class="string">"koa-static"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">let</span> getBaseUrl = <span class="string">"http://localhost:8080"</span>;</span><br><span class="line">app.use(koaStatic(path.join(__dirname, <span class="string">"dist"</span>)));</span><br><span class="line">app.listen(PORT, () =&gt; <span class="built_in">console</span>.log(<span class="string">"running on port "</span> + PORT));</span><br></pre></td></tr></table></figure><p>这样的话你的 .exe 文件就必须放在根目录的 /dist 文件下 ,(electron-builder 默认输<br>出就是 dist 文件 )</p><p>你的文件结构就应该是</p><p>E:\electron_test\dist\ 项目名称 .exe</p><p>当然 项目名称 .exe这个文件你可以随便放在dist文件里的任何一层比如可以/v0.1/项目名称.exe</p><p>但是latest.yml一定要保证能访问到</p><p>当然这只是我的配置 , 只要能够保证能访问就好</p><p><a href="http://localhost:8080/latest.yml能下载就可以" target="_blank" rel="external">http://localhost:8080/latest.yml能下载就可以</a> ;</p><p>接下来修改 package 里的 publish</p><p>publish”: { “provider”: “generic”, “url”: “<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>“ },</p><p>然后就可以设置版本 , 开始打包 ;</p><p>打包结束后再 dist 文件里面会有 win-ia32-unpacked 和 win-unpacked 文件夹 ( 也有可<br>能是两个或者三个 , 反正就是看你打包多少平台)</p><p>就是把程序打包到这个文件里面,让他成为一个electron文件,他里面调用了很多dll模块,主要是操作系统的文件;</p><p>然后通过build打包成.exe文件,这就是安装程序</p><p>然后生成latest.yml文件</p><p>这个文件主要用于更新,如果不适用build -p的话是不会有的;</p><p>每次main里面检查更新的时候,就回去服务器查找latest.yml文件,比对服务器上的版本和自身版本是否相同,如果有更新就会根据配置下载更新,所以latest.yml和项目名称.exe最好要在同一文件夹下面,并且是 autoUpdater.setFeedURL(url)中url的地址;</p><p>latest.yml里有版本,路径,加密,时间等,一般exe是在同路径下,如果不是就改成相应的.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;electron-问题笔记-自动升级配置&quot;&gt;&lt;a href=&quot;#electron-问题笔记-自动升级配置&quot; class=&quot;headerlink&quot; title=&quot;electron 问题笔记 : 自动升级配置&quot;&gt;&lt;/a&gt;electron 问题笔记 : 自动升级配置&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;electron-build 提供的升级方式有很多种 , 目前只预演出了 github 和 http 更新 , 不&lt;br&gt;过足够了 , 这两个应该是最常用的 ;&lt;/p&gt;
    
    </summary>
    
    
      <category term="electron elecron-build" scheme="http://www.gmkgmk.com/tags/electron-elecron-build/"/>
    
  </entry>
  
  <entry>
    <title>electron问题笔记:使用electron-build 打包;</title>
    <link href="http://www.gmkgmk.com/2017/11/30/electron%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://www.gmkgmk.com/2017/11/30/electron问题笔记(一)/</id>
    <published>2017-11-30T05:58:02.399Z</published>
    <updated>2017-12-05T06:28:51.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="electron-问题笔记-打包配置"><a href="#electron-问题笔记-打包配置" class="headerlink" title="electron 问题笔记 : 打包配置"></a>electron 问题笔记 : 打包配置</h2><p>最近在学习 electron 在 win 下面的打包 , 由于以前没有接触过 electron, 所以踩了不<br>少坑 , 这里记录一下 ;</p><p>电脑是 window 10 x64;</p><p>node 使用的 8.4.0;</p><p>npm 是 5.3.0;</p><p>现在的 electron 版本是1.7.9;</p><p><strong>打包工具使用的是 electron-builder, 如果是使用 package 的就不用看了 ..</strong></p><a id="more"></a><h2 id="安装-electron"><a href="#安装-electron" class="headerlink" title="安装 electron"></a>安装 electron</h2><p>全局安装方便一点</p><hr><blockquote><p>npm install electron -g</p></blockquote><p>查看安装成功没<br>electron -v</p><p>首先安装就有很多坑 , 由于某种原因 , 网络下载会一直出错 , 在这里网上的解决方法是<br>设置 npm 源 ;</p><p>在 C:\Users\user 里会又一个 .npmrc 是 npm 的配置文件 ;</p><p>反键打开设置以下内容 ;</p><blockquote><p>phantomjs_cdnurl=<a href="http://npm.taobao.org/mirrors/phantomjs" target="_blank" rel="external">http://npm.taobao.org/mirrors/phantomjs</a><br>sass_binary_site=<a href="https://npm.taobao.org/mirrors/node-sass/" target="_blank" rel="external">https://npm.taobao.org/mirrors/node-sass/</a><br>ELECTRON_MIRROR=<a href="http://npm.taobao.org/mirrors/electron/" target="_blank" rel="external">http://npm.taobao.org/mirrors/electron/</a><br>registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a></p></blockquote><p>如果不能科学上网 , 就尽量多试几次 ;</p><p>实在有包下不来 , 就去这里面下<br><a href="https://npm.taobao.org/mirrors/electron" target="_blank" rel="external">https://npm.taobao.org/mirrors/electron</a><br>相应的版本</p><p>然后放在 C:\Users\user 里面的 .electron 里面 ( 不知道记没记错 , 不对的话再找一下<br>, 网上很多 )</p><h2 id="开始-electron-项目"><a href="#开始-electron-项目" class="headerlink" title="开始 electron 项目"></a>开始 electron 项目</h2><hr><p>因为重点不是使用 electron, 可以简单的使用官网的 electron-quick-start 列子快速开<br>始 demo;</p><p>官网地址 :<a href="https://github.com/electron/electron" target="_blank" rel="external">electron github</a></p><h2 id="electron-builder-打包开始"><a href="#electron-builder-打包开始" class="headerlink" title="electron-builder 打包开始"></a>electron-builder 打包开始</h2><hr><p>使用的是electron-builder ;</p><blockquote><p>npm install electron-builder -g</p></blockquote><p>查看安装成功没<br>build -v</p><p>以前公司是使用electron-package,但是发现这个更符合需求,所以改用这个.两者各有好处</p><p>安装什么的跳过,直接进入配置</p><p>electron-builder 的配置文档写的非常清楚 , 基本上跟着配置就好了 , 这里说下我是怎<br>么配置的 ; electron-builder 的配置文<br>档<a href="https://www.electron.build/" target="_blank" rel="external">electron-builder 的配置文档</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">"build": &#123;</span><br><span class="line">    "appId": "com.id",</span><br><span class="line">    "productName": "项目名称",</span><br><span class="line">    "asar": true,</span><br><span class="line">    "nsis": &#123;</span><br><span class="line">      "artifactName": "$&#123;productName&#125;-x64.$&#123;ext&#125;",</span><br><span class="line">      "runAfterFinish": false,</span><br><span class="line">      "deleteAppDataOnUninstall": true,</span><br><span class="line">      "allowToChangeInstallationDirectory": true,</span><br><span class="line">      "oneClick": false,</span><br><span class="line">      "installerLanguages": "zh_CN",</span><br><span class="line">      "language": 2052,</span><br><span class="line">      "perMachine": true</span><br><span class="line">    &#125;,</span><br><span class="line">    "publish": &#123;</span><br><span class="line">      "provider": "github"</span><br><span class="line">    &#125;,</span><br><span class="line">    "win": &#123;</span><br><span class="line">      "target": [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"target"</span>: <span class="string">"nsis"</span>,</span><br><span class="line">          <span class="attr">"arch"</span>: [<span class="string">"x64"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      "icon": "icon/icon.ico"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里面几个内容比较重要 :</p><p><strong>asar</strong>: 这个是确定打包的时候是否将你的代码转换为二进制文件 , 如果为 false 的话<br>, 安装之后可以在安装路径路查找到你的代码 , 这样方便调试 , 但是会泄露代码 , 所以<br>测试的是为 false, 其他都为 true;</p><p><strong>nsis</strong>:windos下选择的是nsis打包,官网提供了三种,一般都是使用nsis打包;</p><ul><li>“artifactName”: “${productName}-x64.${ext}”,打包后的名字</li><li>“runAfterFinish”: false, 是否在安装完成后自动打开;</li><li>“deleteAppDataOnUninstall”: true, 拆卸文件后是否不用保留资料;</li><li>“allowToChangeInstallationDirectory”: true,是否允许改变安装路径;</li><li>“oneClick”: false,是一键安装还是可以点击下一下</li><li>“installerLanguages”: “zh_CN”, 安装程序语言</li><li>“language”: 2052, 语言选择,2052是中文</li><li>“perMachine”: true 是否安装每个所有用户（每台机器）。</li></ul><p><strong>publish</strong>:发布方式,这个下篇再讲;</p><p><strong>win</strong> 是打包平台;其他参数就不多说了</p><p>注意的是package里的name author description这三个是必填项,对安装包有影响;</p><p>只打包windos包只需要 :”build –win”</p><p>打包并且需要更新build –win  -p always”, -p代表publish, always为一直监控,文章很详细,不过多阐述;</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;electron-问题笔记-打包配置&quot;&gt;&lt;a href=&quot;#electron-问题笔记-打包配置&quot; class=&quot;headerlink&quot; title=&quot;electron 问题笔记 : 打包配置&quot;&gt;&lt;/a&gt;electron 问题笔记 : 打包配置&lt;/h2&gt;&lt;p&gt;最近在学习 electron 在 win 下面的打包 , 由于以前没有接触过 electron, 所以踩了不&lt;br&gt;少坑 , 这里记录一下 ;&lt;/p&gt;
&lt;p&gt;电脑是 window 10 x64;&lt;/p&gt;
&lt;p&gt;node 使用的 8.4.0;&lt;/p&gt;
&lt;p&gt;npm 是 5.3.0;&lt;/p&gt;
&lt;p&gt;现在的 electron 版本是1.7.9;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打包工具使用的是 electron-builder, 如果是使用 package 的就不用看了 ..&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="electron elecron-build" scheme="http://www.gmkgmk.com/tags/electron-elecron-build/"/>
    
  </entry>
  
  <entry>
    <title>过去杂写整理:git使用</title>
    <link href="http://www.gmkgmk.com/2017/11/30/GIT%E6%95%99%E7%A8%8B/"/>
    <id>http://www.gmkgmk.com/2017/11/30/GIT教程/</id>
    <published>2017-11-30T04:15:00.725Z</published>
    <updated>2017-12-01T03:55:54.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT-教程"><a href="#GIT-教程" class="headerlink" title="GIT 教程"></a>GIT 教程</h1><h2 id="这篇文章是以前在网上收集的-如果侵权请联系-马上删除"><a href="#这篇文章是以前在网上收集的-如果侵权请联系-马上删除" class="headerlink" title="这篇文章是以前在网上收集的 , 如果侵权请联系 , 马上删除 ;"></a>这篇文章是以前在网上收集的 , 如果侵权请联系 , 马上删除 ;</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>git 是一种分布式版本控制工具。目前项目中比较常见的版本控制器有 SVN、CVS 等，这些<br>版本控制工具属于集中式版本控制器。</p><p>集中式版本控制器的主要特点就是项目的版本库保存在服务器，该服务器和开发人员的开发<br>机要在同一网段中，开发机从服务器 down 下项目，然后进行开发，开发过程中需要实时地<br>将新的版本更新到服务器。一旦服务器挂掉了，整个开发就会受到很大的影响。</p><p>分布式版本控制器的主要特点就是不需要专用服务器，每台开发机都有独立的版本库，相当<br>于每台开发机都是服务器，开发机之间可以互相传递版本内容。由于没有中央服务器，也不<br>用担心网络中断后影响开发。当然，为了方便传递数据，也可以建立一个专门用来交换数据<br>的服务器，比如 github 就充当着这个角色。</p><a id="more"></a><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><p>不同系统下安装 git 有所不同：</p><h4 id="LINUX-上安装"><a href="#LINUX-上安装" class="headerlink" title="LINUX 上安装"></a>LINUX 上安装</h4><p>Ubuntu 或 Debian 系统： sudo apt-get install git 其他 Linux 系统可以是用源码安装<br>。</p><h4 id="MAC-OS-X-上安装"><a href="#MAC-OS-X-上安装" class="headerlink" title="MAC OS X 上安装"></a>MAC OS X 上安装</h4><ul><li>方法 1：homebrew ，然后通过 homebrew 安装 git，参<br>考<a href="http://brew.sh/" target="_blank" rel="external">http://brew.sh/</a> 。</li><li>方法 2：是用 xcode。</li></ul><h4 id="Windows-上安装"><a href="#Windows-上安装" class="headerlink" title="Windows 上安装"></a>Windows 上安装</h4><p>windows 上安装是采用模拟 Linux 环境下进行的，所以需要先安装模拟环境。目前有个非<br>常好的模拟环境工具，其集成了 Linux 环境和 git，这个工具就是 msysgit，从官网下载<br>下来后直接安装即可。下载网<br>址<a href="https://git-for-windows.github.io/" target="_blank" rel="external">https://git-for-windows.github.io/</a></p><p>安装完成后可执行文件有 3 个：</p><ol><li>git bash<ul><li>仿 Linux 命令行</li></ul></li><li>git cmd<ul><li>windows 命令行</li></ul></li><li>git gui<ul><li>可视化窗口</li></ul></li></ol><p>最常用的应该是 git bash，毕竟 git 最适合的环境就是 Linux。可视化窗口工具只是个辅<br>助工具，是用命令操作才是最灵活和快捷的选择。因此接下来主要学习 git 的各种命令。</p><p>虽然 git 的命令比较多，但是常用的就是那 10 多种。</p><p>安装完成后，需要进一步设置用户名和 email。因为 git 是分布式版本控制工具，因此需<br>要每台开发机自报家门。</p><pre><code>$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><p>其中 –global 表示将设置内容配置到全局，这样整个系统的用户都应用这个设置。后面我<br>们还将介绍直接在配置文件中设置的方法。</p><h4 id="git-的各种命令"><a href="#git-的各种命令" class="headerlink" title="git 的各种命令"></a>git 的各种命令</h4><ul><li><a href="#init">git init</a> - 初始化版本库</li><li><a href="#add">git add</a> - 将增加或修改内容放到暂存库</li><li><a href="#commit">git commit</a> - 提交暂存库的内容</li><li><a href="#status">git status</a> - 查看状态</li><li><a href="#diff">git diff</a> - 比较两次版本的不同</li><li><a href="#log">git log</a> - 查看版本日志</li><li><a href="#reflog">git reflog</a> - 查看执行的命令日志</li><li><a href="#reset">git reset</a> - 回退历史版本</li><li><a href="#rm">git rm</a> - 从版本库中删除</li><li><a href="#checkout">git checkout</a> - 切换分支</li><li><a href="#branch">git branch</a> - 创建或查看分支</li><li><a href="#merge">git merge</a> - 合并分支</li><li><a href="#stash">git stash</a> - 存储工作区</li><li><a href="#tag">git tag</a> - 创建或查看标签</li><li><a href="#remote">git remote</a> - 查看远程版本库的名称</li><li><a href="#push">git push</a> - 推送本地库版本到远程库</li><li><a href="#pull">git pull</a> - 从远程库拉取到本地库</li><li><a href="#clone">git clone</a> - 从远程或本地克隆版本库到指定位置</li></ul><h4 id="init">git init</h4><p>将空目录或者有内容的目录加入到 git 版本控制器中，由 git 来跟踪并管理。</p><pre><code>git init</code></pre><p>命令执行完后，会在当前目录下生成一个 .git 的目录，该目录是隐藏的。这个目录不能轻<br>易改动，里面保存着所有的 git 配置。</p><h4 id="add">git add</h4><p>将增加或修改的文件保存到暂存库中。</p><pre><code>git add [文件]</code></pre><p>将所有改动的文件都存放到暂存库。 git add -A</p><h4 id="commit">git commit</h4><p>将暂存区的内容提交到版本库。每次提交都必须将提交的注释加上。</p><pre><code>git commit -m &quot;注释&quot;</code></pre><p>如果文件的修改或删除没有通过 add 或 rm 放入暂存区，也可以通过加入 -a 的参数直接<br>提交。( 增加必须通过 add 加入暂存区 )</p><pre><code>git commit -a -m &quot;注释&quot;</code></pre><h4 id="status">git status</h4><p>查看文件有没有被修改的状态，无论文件是否放入暂存区，只要 git 监控到文件增加、修<br>改、删除，都可以使用该命令来查看。</p><pre><code>git status</code></pre><h4 id="diff">git diff</h4><p>比较未提交到暂存区的修改和上个版本的差别。</p><pre><code>git diff [文件]</code></pre><p>比较所有提交到暂存区的文件。</p><pre><code>git diff</code></pre><h4 id="log">git log</h4><p>查看操作日志，记录所有提交后的版本信息。可以根据日志信息回退到指定的版本。</p><pre><code>git log</code></pre><p>查看分支合并图</p><pre><code>git log --graph格式化显示效果$ git log --graph --pretty=oneline --abbrev-commit</code></pre><h4 id="reflog">git reflog</h4><p>查看所有执行的命令历史。</p><pre><code>git reflog</code></pre><h4 id="reset">git reset</h4><p>回退历史版本。如果执行提交后又反悔了，可以通过该命令进行回退。</p><p>回退到当前版本，比如放弃当前未提交的修改。</p><pre><code>git reset --hard head</code></pre><p>如果要回退上一个版本，则改成 git reset –hard head~1 head~ 后面跟数字，表示回退<br>到从当前版本往回数第几个版本。</p><p>也可以指定回退到某一个版本。首先通过 git log，查看版本的 id 号，再根据 id 号来回<br>退。id 号可只写前四位。</p><pre><code>git reset --hard [id]</code></pre><h4 id="rm">git rm</h4><p>删除文件有两种方式</p><ol><li><p>直接从文件夹中删除，但是版本库中并没有被删，如果需要提交版本库就要用到 git<br>rm，再使用 git commit 提交。</p></li><li><p>使用 git rm 删除，文件会从版本库和工作区都删除，然后使用 git commit 提交。</p></li></ol><p>用法：</p><pre><code>git rm [文件]</code></pre><h4 id="checkout">git checkout</h4><p>切换分支。</p><pre><code>git checkout [分支名称]</code></pre><p>创建并切换到该分支。</p><pre><code>git checkout -b [分支名称]</code></pre><h4 id="branch">git branch</h4><p>查看分支。</p><pre><code>git branch</code></pre><p>创建分支。 git branch [分支名称]</p><p>删除分支。</p><pre><code>git branch -d [分支名称]</code></pre><p>如果删除的分支没有被合并，需要进行强制删除。</p><pre><code>git branch -D [分支名称]</code></pre><h4 id="merge">git merge</h4><p>快速合并，直接改变合并分支的指针。如果合并的分支间有冲突，则需要手动解决冲突后再<br>提交。</p><pre><code>git merge [合并的分支名称]</code></pre><p>快速合并分支后，如果删除分支则日志记录中不会记录分支合并的操作。如果希望能记录分<br>支合并的操作，则需要禁用快速合并。</p><pre><code>git merge --no-ff</code></pre><h4 id="stash">git stash</h4><p>存储当前工作区。如果任务进行到一半，需要解决其他版本的问题，比如修复 BUG。当前进<br>行的操作可暂时保存下来，解决问题再恢复。</p><pre><code>git stash</code></pre><p>查看所有保存的工作现场。</p><pre><code>git stash list</code></pre><p>恢复保存的工作现场。</p><pre><code>git stash apply [工作现场名称]恢复后删除工作现场git stash drop [工作现场名称]</code></pre><p>恢复最后保存的工作现场并同时删除</p><pre><code>git stash pop</code></pre><h4 id="tag">git tag</h4><p>给最新的版本加上标签。</p><pre><code>git tag [标签号]</code></pre><p>给历史版本加上标签。版本 id 可以通过 git log 查看。</p><pre><code>git tag [标签号] [版本id]</code></pre><p>创建带有说明的标签。 git tag -a [标签号] -m “ 标签说明 “ [版本 id] 删除标签。</p><pre><code>git tag -d [标签号]</code></pre><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>如果不想搭建自己的 git 服务器，可以选择使用 Github。这个网站就是提供 Git 仓库托<br>管服务的，所以，只要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库</p><p>第 1 步：创建 SSH Key。在用户主目录下，看看有没有 .ssh 目录，如果有，再看看这个<br>目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如<br>果没有，打开 Shell（Windows 下打开 Git Bash），创建 SSH Key：</p><pre><code>$ ssh-keygen -t rsa -C [你的email]</code></pre><p>如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub<br>两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub<br>是公钥，可以放心地告诉任何人。</p><p>第 2 步：登陆 GitHub，打开 “Account settings”，“SSH Keys” 页面：</p><p>然后，点 “Add SSH Key”，填上任意 Title，在 Key 文本框里粘贴 id_rsa.pub 文件的内<br>容。</p><p>当然，GitHub 允许你添加多个 Key。假定你有若干电脑，你一会儿在公司提交，一会儿在<br>家里提交，只要把每台电脑的 Key 都添加到 GitHub，就可以在每台电脑上往 GitHub 推送<br>了。</p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>现在的情景是，你已经在本地创建了一个 Git 仓库后，又想在 GitHub 创建一个 Git 仓库<br>，并且让这两个仓库进行远程同步，这样，GitHub 上的仓库既可以作为备份，又可以让其<br>他人通过该仓库来协作，真是一举多得。</p><p>首先，登陆 GitHub，然后，在右上角找到 “Create a new repo” 按钮，创建一个新的仓库<br>。</p><p>在 Repository name 填入 learngit，其他保持默认设置，点击 “Create repository” 按<br>钮，就成功地创建了一个新的 Git 仓库。</p><p>目前，在 GitHub 上的这个 learngit 仓库还是空的，GitHub 告诉我们，可以从这个仓库<br>克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到<br>GitHub 仓库。</p><h4 id="remote">git remote</h4><p>通过 git remote 命令关联远程库。</p><pre><code>git remote add origin [你的github地址]</code></pre><p>查看远程库信息</p><pre><code>git remote -v</code></pre><h4 id="push">git push</h4><p>将本地库提交到远程库</p><pre><code>git push origin [分支名称]或git push origin -u [分支名称]</code></pre><p>由于远程库是空的，我们第一次推送 master 分支时，加上了 -u 参数，Git 不但会把本地<br>的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的<br>master 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><h4 id="pull">git pull</h4><p>如果向远程库推送失败，有可能远程库已有新版本导致冲突，那么需要使用 git pull 从远<br>程库将新版本拉取到本地，手动解决后再推送。</p><pre><code>git pull</code></pre><p>如果 pull 也失败，有可能没有与远程库关联，下面是关联方法：</p><pre><code>git branch --set-upstream [分支名称] origin/[分支名称]</code></pre><h3 id="远程克隆"><a href="#远程克隆" class="headerlink" title="远程克隆"></a>远程克隆</h3><h4 id="clone">git clone</h4><p>如果远程已有库，可以通过 git clone 将远程库的内容克隆到本地。</p><pre><code>git clone [你的git地址]</code></pre><p>从远程克隆下来的项目只能看到 master 分支，如果要抓取其他分支可以使用 git<br>checkout。</p><pre><code>git checkout -b dev1 origin/dev1</code></pre><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>在项目中往往有些文件不需要受 git 控制，比如中间的编译文件、系统生成的配置文件等<br>等，那么可以在项目的根目录下建立一个后缀名为 .gitignore 的文件，将需要忽略的文件<br>或文件夹写在里面即可。.gitignore 文件需要提交到 git 版本控制中。</p><p>比如该文件可有如下配置：</p><pre><code># Windows:Thumbs.dbehthumbs.dbDesktop.ini# My configurations:db.inideploy_key_rsadistbuild</code></pre><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>上面很多命令都很长，而每次都去敲相同的命令显得比较繁琐。git 还提供了配置别名的方<br>法，可以将很长的命令进行简化。配置的方法有两种：</p><ol><li><p>命令行配置</p><pre><code>#给git status设置别名st:git config --global alias.st &quot;status&quot;#以后就可以调用git st来获取文件的状态。</code></pre></li><li><p>在配置文件中设置</p><p>如果嫌命令行操作太过于麻烦，也可以到用户的根目录下找到 .gitconfig 文件，直接<br>修改该文件内容也可以到达设置的效果。</p><pre><code>#下面是.gitconfig文件的设置：[user]name = bdkemail = 12899931@qq.com[alias]last = log -1#美化日志输出的效果lg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commitst = statusck = checkoutckb = checkout -bcm = commit -a -m...</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GIT-教程&quot;&gt;&lt;a href=&quot;#GIT-教程&quot; class=&quot;headerlink&quot; title=&quot;GIT 教程&quot;&gt;&lt;/a&gt;GIT 教程&lt;/h1&gt;&lt;h2 id=&quot;这篇文章是以前在网上收集的-如果侵权请联系-马上删除&quot;&gt;&lt;a href=&quot;#这篇文章是以前在网上收集的-如果侵权请联系-马上删除&quot; class=&quot;headerlink&quot; title=&quot;这篇文章是以前在网上收集的 , 如果侵权请联系 , 马上删除 ;&quot;&gt;&lt;/a&gt;这篇文章是以前在网上收集的 , 如果侵权请联系 , 马上删除 ;&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;git 是一种分布式版本控制工具。目前项目中比较常见的版本控制器有 SVN、CVS 等，这些&lt;br&gt;版本控制工具属于集中式版本控制器。&lt;/p&gt;
&lt;p&gt;集中式版本控制器的主要特点就是项目的版本库保存在服务器，该服务器和开发人员的开发&lt;br&gt;机要在同一网段中，开发机从服务器 down 下项目，然后进行开发，开发过程中需要实时地&lt;br&gt;将新的版本更新到服务器。一旦服务器挂掉了，整个开发就会受到很大的影响。&lt;/p&gt;
&lt;p&gt;分布式版本控制器的主要特点就是不需要专用服务器，每台开发机都有独立的版本库，相当&lt;br&gt;于每台开发机都是服务器，开发机之间可以互相传递版本内容。由于没有中央服务器，也不&lt;br&gt;用担心网络中断后影响开发。当然，为了方便传递数据，也可以建立一个专门用来交换数据&lt;br&gt;的服务器，比如 github 就充当着这个角色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js git" scheme="http://www.gmkgmk.com/tags/js-git/"/>
    
  </entry>
  
  <entry>
    <title>过去杂写整理:关于闭包的理解</title>
    <link href="http://www.gmkgmk.com/2017/11/30/%E9%97%AD%E5%8C%85/"/>
    <id>http://www.gmkgmk.com/2017/11/30/闭包/</id>
    <published>2017-11-30T04:13:28.284Z</published>
    <updated>2017-12-01T03:56:20.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于闭包的理解"><a href="#关于闭包的理解" class="headerlink" title="关于闭包的理解"></a>关于闭包的理解</h2><p><strong>闭包是由函数引用其周边状态 ( 所在的上下文 ) 绑定在一起形成的组合状态 ;</strong> <strong>闭<br>包让我们能够从一个函数内部访问其外部函数的作用域。</strong></p><a id="more"></a><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p><em>闭包就是两个函数嵌套 , 内部函数引用了外部函数的值 , 使这个值的引用一只不为零 ,<br>是这个变量得以长期保存 ;(js 垃圾回收机制是消除引用为 0 的对象 );</em></p><h3 id="闭包产生是与作用域相关的"><a href="#闭包产生是与作用域相关的" class="headerlink" title="闭包产生是与作用域相关的 ;"></a>闭包产生是与作用域相关的 ;</h3><ol><li>当 js 执行代码的时候 , 开始读取的时候会产生一个全局上下文 , 里面有全局作用域<br>( 可以想象成洋葱的外圈 );</li><li>当读取到一个函数时 , 就会开辟一个新的执行上下文 ( 洋葱的内圈 ), 里面会有新的<br>作用域 , 一个新的上下文 , 由于作用域链 , 内部可以读取外面的作用域 ;</li><li>当内部函数引用了外部值的时候 , 就产生了闭包 ;</li></ol><h4 id="列子-1"><a href="#列子-1" class="headerlink" title="列子 1"></a>列子 1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = A();</span><br></pre></td></tr></table></figure><p>函数 B 引用的 a 作用域理 count 的值 ;(A 的作用域 &gt;B 的作用域 ;B 引用 A 作用域里<br>的东西 ; 然后返回 B 的引用 , 让全局 c 保存 B 的引用 )</p><h2 id="作用域和执行上下文"><a href="#作用域和执行上下文" class="headerlink" title="作用域和执行上下文"></a>作用域和执行上下文</h2><p>js 是异步的 , 代码一段一段的执行 , 系统会首先声明函数声明和变量声明 ;</p><p>然后 js 代码一段接着一段的执行 ;</p><p>因为 js 的函数级作用域 , 执行到一个函数的时候 , 就开辟一个执行上下文 , 进去这个<br>作用域的时候 , 会开辟当前作用域 , 并声明自己函数内部的函数声明和变量声明 ( 声明<br>但不赋值 );</p><p>然后也是一段一段代码的执行 , 给变量赋值 , 和执行函数 , 执行函数又会再开一个更小<br>一级的执行上下文 .. 就这样一直不断的开辟 , 声明 .. 直到最后代码执行完成了 , 这个<br>上下文就会消失 , 然后又开始执行下一个执行上下文 ;</p><p><em>js 代码就这样一个又一个的不断开辟 , 消失 , 开辟 , 消失 ;</em></p><p>在任何时间点，只能有一个执行上下文运行 , 这就是为什么 JavaScript 被称为 “ 单线程<br>“ 语言游览器在存放执行上下文使用 ‘ 栈 ‘ 来存放执行上下文的 (‘ 栈 ‘ 太高深 , 不是<br>科班出生的小白暂时不能理解 , 只知道是后进先出 , 正在执行的上下文永远在最上面 ,<br>必须他执行完 , 弹出以后才会执行下一个上下文 ;)</p><p>一到很多人都遇到过的面试题 ;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这会打印 5 个 5;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这会打印 0,1,2,3,4;</span></span><br></pre></td></tr></table></figure><p>为什么会这样呢 . 个人理解是因为第一个 setTimeout 是在一个函数作 用域理 , 所用的<br>i 值都是 for 上下文完成后保存的值 , 所以是 5 个 5;setTimeout 是在函数循环结束之<br>后才开辟的上下文环境 ;</p><p>第二个是因为在 for 循环里又开辟了一个 上下文 , 在这个上下文里引用了 for 正在循环<br>的 i, 所以正确的执行 , 执行后 , 上下 文结束 , 又开始下一次循环 ;</p><p>总之 , 他们共享了一个作用域 ;</p><p><a href="http://www.zcfy.cc/article/master-the-javascript-interview-what-is-a-closure-2127.html" target="_blank" rel="external">http://www.zcfy.cc/article/master-the-javascript-interview-what-is-a-closure-2127.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于闭包的理解&quot;&gt;&lt;a href=&quot;#关于闭包的理解&quot; class=&quot;headerlink&quot; title=&quot;关于闭包的理解&quot;&gt;&lt;/a&gt;关于闭包的理解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;闭包是由函数引用其周边状态 ( 所在的上下文 ) 绑定在一起形成的组合状态 ;&lt;/strong&gt; &lt;strong&gt;闭&lt;br&gt;包让我们能够从一个函数内部访问其外部函数的作用域。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://www.gmkgmk.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>过去杂写整理:使用antd时使用babel-import-plugin的坑</title>
    <link href="http://www.gmkgmk.com/2017/11/22/antd%E4%BD%BF%E7%94%A8babel-import-plugin%E9%97%AE%E9%A2%98/"/>
    <id>http://www.gmkgmk.com/2017/11/22/antd使用babel-import-plugin问题/</id>
    <published>2017-11-22T01:29:09.015Z</published>
    <updated>2017-11-30T06:47:12.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在最近的项目中遇到的问题"><a href="#在最近的项目中遇到的问题" class="headerlink" title="在最近的项目中遇到的问题"></a>在最近的项目中遇到的问题</h2><ol><li>引用 babel-import-plugin 报错 “You may need an appropriate loader to handle<br>this file type.”_ webpack 配置如下 :</li></ol><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: <span class="built_in">require</span>.resolve(<span class="string">"babel-loader"</span>),</span><br><span class="line">      query: &#123;</span><br><span class="line">        presets: [<span class="string">"es2015"</span>, <span class="string">"react"</span>],</span><br><span class="line">        plugins: [</span><br><span class="line">          <span class="string">"transform-runtime"</span>,</span><br><span class="line">          [</span><br><span class="line">            <span class="string">"import"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              libraryName: <span class="string">"antd"</span>,</span><br><span class="line">              style: <span class="string">"css"</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">    loader: <span class="string">"style-loader!css-loader!less-loader"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">    loader: <span class="string">"style-loader!css-loader"</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>原因 : 将 node_modules 里面的文件排除在 loader 范围之外 , 导致加载器不编译<br>antd 里的模块导致出错 ;</strong></p><p><strong>解决 : 如果配置的 style:css 则去除 css-loader 里面的 exclude:<br>/(node_modules)/,true 则去除 Less 的 ;</strong></p><ol><li>abel-import-plugin 不生效</li></ol><p><strong>配置了任然提示全局引入 ; 首先检查是否在文件理映入了 antd 的样式文件 , 这是不需<br>要引入的 , 插件自动引入 ; 然后检查 CommonsChunkPlugin 是不是将 antd 引入 .!</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在最近的项目中遇到的问题&quot;&gt;&lt;a href=&quot;#在最近的项目中遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;在最近的项目中遇到的问题&quot;&gt;&lt;/a&gt;在最近的项目中遇到的问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;引用 babel-import-plugin 报错 “You may need an appropriate loader to handle&lt;br&gt;this file type.”_ webpack 配置如下 :&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="react antd js" scheme="http://www.gmkgmk.com/tags/react-antd-js/"/>
    
  </entry>
  
  <entry>
    <title>过去杂写整理:浏览器加载理解:从按下enter到页面渲染</title>
    <link href="http://www.gmkgmk.com/2017/11/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.gmkgmk.com/2017/11/21/浏览器加载过程/</id>
    <published>2017-11-21T14:31:42.125Z</published>
    <updated>2017-12-01T03:56:11.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器加载理解"><a href="#浏览器加载理解" class="headerlink" title="浏览器加载理解"></a>浏览器加载理解</h2><blockquote><h2 id="关于浏览器按下-enter-到-html-生成发生了什么-网上博文和自己的一些理解-做一个积累"><a href="#关于浏览器按下-enter-到-html-生成发生了什么-网上博文和自己的一些理解-做一个积累" class="headerlink" title="关于浏览器按下 enter 到 html 生成发生了什么 , 网上博文和自己的一些理解 , 做一个积累"></a>关于浏览器按下 enter 到 html 生成发生了什么 , 网上博文和自己的一些理解 , 做一个积累</h2></blockquote><a id="more"></a><h3 id="第一步-按下-enter"><a href="#第一步-按下-enter" class="headerlink" title="第一步 : 按下 enter"></a>第一步 : 按下 enter</h3><hr><h4 id="按下-enter-后-浏览器会进行一系列操作"><a href="#按下-enter-后-浏览器会进行一系列操作" class="headerlink" title="按下 enter 后 , 浏览器会进行一系列操作"></a>按下 enter 后 , 浏览器会进行一系列操作</h4><p><strong>浏览器会去寻找缓存 , 如果查找到就直接读取 , 然后流程结束 ;</strong></p><ol><li>首先浏览器是查找网站的本地缓存 ;</li><li>然后查找的是浏览器缓存 , 查看有没有这个网站<em>域名对应的解析过的 IP 地址</em>的缓存<br>;</li><li>浏览器缓存找不到就开始寻找操作用户缓存 , 查看有没有这个网站的缓存 ;</li><li>操作用户缓存还没有找到 , 就去寻找本机有无这个域名对应的 DNS 解析结果 , 进入第<br>二步 ;</li></ol><h3 id="第二步-发起-dns-域名解析服务"><a href="#第二步-发起-dns-域名解析服务" class="headerlink" title="第二步 , 发起 dns 域名解析服务"></a>第二步 , 发起 dns 域名解析服务</h3><hr><h4 id="一般是浏览器发出请求-然后服务器运营商-移动-联动等-发起-dns-解析服务请求"><a href="#一般是浏览器发出请求-然后服务器运营商-移动-联动等-发起-dns-解析服务请求" class="headerlink" title="一般是浏览器发出请求 , 然后服务器运营商 ( 移动 , 联动等 ) 发起 dns 解析服务请求"></a>一般是浏览器发出请求 , 然后服务器运营商 ( 移动 , 联动等 ) 发起 dns 解析服务请求</h4><ol><li>首先寻找顶级域名 ip 地址 , 如 .com,.cn 等 ;</li><li>通过这个地址去寻找次级域名地址 , 就是药请求的那个网站的地址 , 如<br>www.baidu.com,www.google.com;</li><li>然后去寻找网站的 ip 地址 ;</li><li>ip 地址返回给计算机 , 然后计算机给浏览器 , 浏览器发出请求 , 通过三次握手与<br>tcp 连接 , 建立连接 , 请求资源 ;</li></ol><h3 id="第三步-开始建立连接-这一步我的理解就是发起三次握手"><a href="#第三步-开始建立连接-这一步我的理解就是发起三次握手" class="headerlink" title="第三步 , 开始建立连接 ; 这一步我的理解就是发起三次握手"></a>第三步 , 开始建立连接 ; 这一步我的理解就是发起三次握手</h3><ol><li>首先询问 , 发起连接请求 , 就是先询问服务器是不是可以建立连接 ; - 然后服务器回<br>答 , 可以连接 ;</li><li>浏览器再次发出信号 , 开始建立连接 ;</li></ol><p>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次 ( 第一次和第<br>二次 ) 握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次<br>( 第二次和第三次 ) 握手。</p><p>详情参考 :<br><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="external">通俗大白话来理解 TCP 协议的三次握手和四次分手</a></p><p>对于这部分个人理解还是太弱 , 主要是接触不到 .. 看不到实质问题 .. 求各路大神指导<br>或者好文章分享一下 ;</p><h3 id="第四步-连接开始后-就开始请求各种资源"><a href="#第四步-连接开始后-就开始请求各种资源" class="headerlink" title="第四步 , 连接开始后 , 就开始请求各种资源"></a>第四步 , 连接开始后 , 就开始请求各种资源</h3><ol><li><p>首先是根据服务器内一系列处理</p></li><li><p>然后开始请求 html 页面 ;</p></li><li>浏览器接收到返回来的 html 页面 , 就开始按照文档流读取里面的标签 , 每读到一个<br>css,js,img, 有开启一个新的连接 ;</li><li>开始建立 Dom 树 : 通过读取 html 文档 , 从上到下读取 , 将 html 元素变成一个个<br>节点 , 开始建立 cssom 树 : 当浏览器发现任何与节点相关的 , 就立即停止渲染 dom,<br>然后创建 cssom;</li><li>在 dom 树很 cssom 树创建的过程中 , 一旦发现 js 文件 ,( 就是遇到 script 的时候<br>), 就会停止渲染 , 然后异步解析 js( 就是执行 js); <strong>这就是为什么最好 js 放在<br>html 页面最后的原因 , 为了防止网络传输中 ,js 太慢 , 导致浏览器留白</strong> ;</li><li>当 dom 树与 cssom 树创建完成后 , 就会开始合并 , 然后渲染页面 ( 一旦所有节点已<br>被读取 ,DOM 和 CSSOM 准备好合并 , 浏览器就会构建渲染树。);</li></ol><p>详情参考 :<br><a href="http://www.zcfy.cc/article/optimising-the-front-end-for-the-browser-hacker-noon-2847.html" target="_blank" rel="external">浏览器前端优化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浏览器加载理解&quot;&gt;&lt;a href=&quot;#浏览器加载理解&quot; class=&quot;headerlink&quot; title=&quot;浏览器加载理解&quot;&gt;&lt;/a&gt;浏览器加载理解&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;关于浏览器按下-enter-到-html-生成发生了什么-网上博文和自己的一些理解-做一个积累&quot;&gt;&lt;a href=&quot;#关于浏览器按下-enter-到-html-生成发生了什么-网上博文和自己的一些理解-做一个积累&quot; class=&quot;headerlink&quot; title=&quot;关于浏览器按下 enter 到 html 生成发生了什么 , 网上博文和自己的一些理解 , 做一个积累&quot;&gt;&lt;/a&gt;关于浏览器按下 enter 到 html 生成发生了什么 , 网上博文和自己的一些理解 , 做一个积累&lt;/h2&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://www.gmkgmk.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>过去杂写整理:执行上下文理解</title>
    <link href="http://www.gmkgmk.com/2017/11/21/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://www.gmkgmk.com/2017/11/21/执行上下文/</id>
    <published>2017-11-21T14:25:32.336Z</published>
    <updated>2017-12-01T03:56:05.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天拜读了一篇博文-感觉又突破了-对堆栈和上下文又有了一个新的认识"><a href="#今天拜读了一篇博文-感觉又突破了-对堆栈和上下文又有了一个新的认识" class="headerlink" title="今天拜读了一篇博文 , 感觉又突破了 , 对堆栈和上下文又有了一个新的认识"></a>今天拜读了一篇博文 , 感觉又突破了 , 对堆栈和上下文又有了一个新的认识</h2><h2 id="堆和栈的梳理"><a href="#堆和栈的梳理" class="headerlink" title="堆和栈的梳理"></a>堆和栈的梳理</h2><p>以前只知道堆和栈是 js 处理内存的方法 . 栈是先进后出 frist in last out , 后进先出<br>last in frist out!</p><p><strong>堆就感觉是把书放在一个书架上面 , 你只需要知道它名字 , 就可以找到他 .</strong></p><p><strong>栈就感觉把书放一个大小刚好的箱子里 , 你想要下面的就必须要把上面的拿出来 ;</strong></p><a id="more"></a><p>基础数据类型都是按值访问 ; 比如 a=1,b=a, 这都是在堆里面进行操作 , 重新复制了一个<br>值 , 所以这时当你更改 b 的值 b=2, 而 a 依然是 1, 因为他们其实是<strong>不一样的个体</strong>;</p><p>引用数据类型则不一样 , 引用类型访问都是访问的它的指针 , 指向的是他在堆内存的地址<br>,<strong>复制他的值 , 其实只是复制了他的指针 , 它仍然是指向内存中的那个值</strong>; 比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> n = m;</span><br><span class="line">n.a = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>将 m 赋给 n, 其实 n 只是复制的 m 的指针 , 都是指向堆中 { a: 10, b: 20 } 的位置 ;</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p><strong>JavaScript 被称为 “ 单线程 “ 语言 , 是因为同一时间点 , 只能有一个执行上下文运<br>行 !</strong></p><p>JavaScript 在处理上下文时会使用栈的方式处理 . 所以是栈是<strong>先进后出 , 后进先出</strong>,<br>越先进的越在下面 , 越后释放反之亦然 !</p><ul><li>浏览器一进入 , 会生成全局上下文 , 里面会保存一系列的变量 , 并将全局上下文压入<br>栈 , 当 js 代码一句句执行的时候 , 执行到一个函数 , 就创建一个函数及执行上下文<br>(js 是函数及作用域 !);</li><li>创建函数级作用于后 , 也会首先申明一系列变量 , 然后就将这个函数及上下文压入栈 ,<br>放在全局上下文上面 , 如果再次遇到执行函数 , 就又会创建一个执行上下文 , 又压入<br>栈 ;</li><li>直到函数运行完没有在建立执行上下文 ( 没有执行函数 ), 这个上下文就会消失 , 然后<br>弹出栈 , 然后继续运行 ;</li></ul><p>写到这里突然想到了一个情况 :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  c++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line">  a();</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>在 b 的上下文内 , 执行全局上下文的 a 函数 ; 这种写法会报错 , 因为 a 里面保存的依<br>然是全局作用域 ( <strong>函数的作用域是在它声明的上下文</strong> )!</p><p>全局作用域无法读取下层作用域的值如果在 a 的函数声明前加一个 var c = 2; 这段代码<br>则也会打印 b 作用域理声明的 c 所以为 1;</p><p>这只是突然的想法 ; 继续来说执行上下文 ;</p><p>引用一下大神的总结 :</p><ol><li>单线程</li><li>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</li><li>全局上下文只有唯一的一个，它在浏览器关闭时出栈</li><li>函数的执行上下文的个数没有限制</li><li>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也<br>是如此。</li></ol><p>注意的是 return 的时候上下文立即结束 , 上下文立即弹出栈 !</p><p>总结 : 上下文很多概念都是以前清楚了的 , 很基础的东西 , 但是这次拉上堆栈 , 感觉对<br>堆栈有了更深的了解 . <a href="http://www.jianshu.com/p/a6d37c77e8db" target="_blank" rel="external"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;今天拜读了一篇博文-感觉又突破了-对堆栈和上下文又有了一个新的认识&quot;&gt;&lt;a href=&quot;#今天拜读了一篇博文-感觉又突破了-对堆栈和上下文又有了一个新的认识&quot; class=&quot;headerlink&quot; title=&quot;今天拜读了一篇博文 , 感觉又突破了 , 对堆栈和上下文又有了一个新的认识&quot;&gt;&lt;/a&gt;今天拜读了一篇博文 , 感觉又突破了 , 对堆栈和上下文又有了一个新的认识&lt;/h2&gt;&lt;h2 id=&quot;堆和栈的梳理&quot;&gt;&lt;a href=&quot;#堆和栈的梳理&quot; class=&quot;headerlink&quot; title=&quot;堆和栈的梳理&quot;&gt;&lt;/a&gt;堆和栈的梳理&lt;/h2&gt;&lt;p&gt;以前只知道堆和栈是 js 处理内存的方法 . 栈是先进后出 frist in last out , 后进先出&lt;br&gt;last in frist out!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆就感觉是把书放在一个书架上面 , 你只需要知道它名字 , 就可以找到他 .&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈就感觉把书放一个大小刚好的箱子里 , 你想要下面的就必须要把上面的拿出来 ;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js context 原理" scheme="http://www.gmkgmk.com/tags/js-context-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
