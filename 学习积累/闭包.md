>关于闭包的理解:

##-闭包是由函数引用其周边状态(所在的上下文)绑定在一起形成的组合状态;
##-闭包让我们能够从一个函数内部访问其外部函数的作用域。

个人理解:
闭包就是两个函数嵌套,内部函数引用了外部函数的值,使这个值的引用一只不为零,是这个变量得以长期保存;(js垃圾回收机制是消除引用为0的对象);

闭包产生是与作用域相关的;
-当js执行代码的时候,开始读取的时候会产生一个全局上下文,里面有全局作用域(可以想象成洋葱的外圈);
-当读取到一个函数时,就会开辟一个新的执行上下文(洋葱的内圈),里面会有新的作用域,一个新的上下文,由于作用域链,内部可以读取外面的作用域;
-当内部函数引用了外部值的时候,就产生了闭包;
####列子1:
> function A(){
    var count = 0;
    function B(){
       count ++;
       console.log(count);
    }
    return B;
}
var c = A();

函数B引用的a作用域理count的值;(A的作用域>B的作用域;B引用A作用域里的东西;然后返回B的引用,让全局c保存B的引用)

作用域和执行上下文:
js是异步的,代码一段一段的执行,系统会首先声明函数声明和变量声明;

然后js代码一段接着一段的执行;
因为js的函数级作用域;
执行到一个函数的时候,就开辟一个执行上下文,进去这个作用域的时候,会开辟当前作用域,并声明自己函数内部的函数声明和变量声明(声明但不赋值);
然后也是一段一段代码的执行,给变量赋值,和执行函数,执行函数又会再开一个更小一级的执行上下文..就这样一直不断的开辟,声明..
直到最后代码执行完成了,这个上下文就会消失,然后又开始执行下一个执行上下文;

js代码就这样一个又一个的不断开辟,消失,开辟,消失;


在任何时间点，只能有一个执行上下文运行,这就是为什么JavaScript被称为"单线程"语言
游览器在存放执行上下文使用'栈'来存放执行上下文的('栈'太高深,不是科班出生的小白暂时不能理解,只知道是后进先出,正在执行的上下文永远在最上面,必须他执行完,弹出以后才会执行下一个上下文;)


一到很多人都遇到过的面试题;
>for(var i = 0 ;i<5;i++){
>  setTimeout(function(){
>    console.log(i)
>  },100)
>}
这会打印5个5;

>for(var i = 0 ;i<5;i++){
>
>  (function (i) {
>    setTimeout(function () {
>      console.log(i)
>    }, 100)
>  })(i)
>}
这会打印0,1,2,3,4;
为什么会这样呢.
个人理解是因为第一个setTimeout是在一个函数作用域理,所用的i值都是for上下文完成后保存的值,所以是5个5;setTimeout是在函数循环结束之后才开辟的上下文环境;
第二个是因为在for循环里又开辟了一个上下文,在这个上下文里引用了for正在循环的i,所以正确的执行,执行后,上下文结束,又开始下一次循环;


[](http://www.zcfy.cc/article/master-the-javascript-interview-what-is-a-closure-2127.html)
对于闭包理解还是不太深刻...球大婶指导啊.489300860,求好书推荐!
