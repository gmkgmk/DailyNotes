今天拜读了一篇博文,感觉又突破了,对堆栈和上下文又有了一个新的认识;

##堆和栈的梳理;
以前只知道堆和栈是js处理内存的方法.栈是先进后出frist in last out ,后进先出last in frist out!

堆就感觉是把书放在一个书架上面,你只需要知道它名字,就可以找到他.
栈就感觉把书放一个大小刚好的箱子里,你想要下面的就必须要把上面的拿出来;

基础数据类型都是按值访问,比如a=1,b=a,这都是在堆里面进行操作,重新复制了一个值,所以这时当你更改b的值b=2,而a依然是1,因为他们其实是不一样的个体;
引用数据类型则不一样,引用类型访问都是访问的它的指针,指向的是他在堆内存的地址,复制他的值,其实只是复制了他的指针,它仍然是指向内存中的那个值;
比如
>var m = { a: 10, b: 20 }
>var n = m;
>n.a = 15;

将m赋给n,其实n只是复制的m的指针,都是指向堆中 { a: 10, b: 20 }的位置;

##执行上下文
JavaScript被称为"单线程"语言,是因为同一时间点,只能有一个执行上下文运行!
JavaScript在处理上下文时会使用栈的方式处理.所以是栈是先进后出,后进先出,越先进的越在下面,越后释放反之亦然!


浏览器一进入,会生成全局上下文,里面会保存一系列的变量,并将全局上下文压入栈,当js代码一句句执行的时候,执行到一个函数,就创建一个函数及执行上下文(js是函数及作用域!);
创建函数级作用于后,也会首先申明一系列变量,然后就将这个函数及上下文压入栈,放在全局上下文上面,如果再次遇到执行函数,就又会创建一个执行上下文,又压入栈;
直到函数运行完没有在建立执行上下文(没有执行函数),这个上下文就会消失,然后弹出栈,然后继续运行;

写到这里突然想到了一个情况:

>function a() {
  c++;
>};

>function b() {
>  var c = 1;
>  a();
>  console.log(c);
>};

>b();

在b的上下文内,执行全局上下文的a函数;
这种写法会报错,因为a里面保存的依然是全局作用域(函数的作用域是在它声明的上下文)!全局作用域无法读取下层作用域的值;
如果在a的函数声明前加一个var c = 2;这段代码则也会打印b作用域理声明的c所以为1;


这只是突然的想法;继续来说执行上下文;

引用一下大神的总结:
1.单线程
2.同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待
3.全局上下文只有唯一的一个，它在浏览器关闭时出栈
4.函数的执行上下文的个数没有限制
5.每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。

主义的是return的时候上下文立即结束,上下文立即弹出栈!

总结:上下文很多概念都是以前清楚了的,很基础的东西,但是这次拉上堆栈,感觉对堆栈有了更深的了解.
[](http://www.jianshu.com/p/a6d37c77e8db)